---
title: "バグチケットを可視化する"
output:
  html_document:
    df_print: paged
    code_folding: hide
    css: style.css
---

<!-- shared Links -->
```{r index, child="../shared/links.Rmd", include=FALSE}
```

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(warning = FALSE, echo = TRUE, message = FALSE)

require(tidyverse)
```

バグトラッキングシステム（以降、BTS）のチケットデータには様々な情報が記録されており品質分析に使わない手はありません。バグチケットの分析は個々のチケットに対する定性分析を行うことが多いですが、ODC分析のようにクロス集計を用いる方法もあります。ODC分析にはODC分析用のタグが必要ですが、ここでは基本的なバグチケットにある情報（項目）を用いた可視化の方法を探って行きます。  
　  

なお、本ページでは`r R.version$version.string`の標準パッケージ以外に以下の追加パッケージを用いています。  
　  

Package   | Version |Description
----------|---------|----------------------------------------------------------
tidyverse | `r packageVersion('tidyverse')` | Easily Install and Load the ‘Tidyverse’

　  
また、本ページでは以下のデータセットを用いています。  
　  

Dataset    | Package  | Version | Description
-----------|----------|---------|----------------------------------------------
redmine    | N/A      | N/A     | [Redmine Issues <i class="fa fa-external-link"></i>](http://www.redmine.org/projects/redmine/issues){target="_blank" title="redmine.org"}

　  

バグチケットは[Redmine <i class="fa fa-external-link"></i>](http://www.redmine.org/){target="_blank" title="Redmine.org"}が公開しているRedmine自体のバグチケットを用います。RedmineはGPL v2ライセンスの下で提供されているオープンソースのプロジェクト管理ソフトウェアです。上の表の場所でチケットを公開していますが、一度に50レコードまでしかダウンロードできないため事前にこちらで取得したレコードをデータフレーム形式にまとめたものを利用します。なお、[Redmine <i class="fa fa-external-link"></i>](http://www.redmine.org/){target="_blank" title="Redmine.org"}ではREST APIを利用してJSON形式でのチケットう情報の取得が可能ですが、REST APIでは一度に25件しかチケットを取得できない点に注意してください。  
　  

# チケット情報のインポート
前述のように今回は事前に整理したデータフレーム形式のチケット情報を用いますが、実際にはBTSのAPI機能やBTSのDBMSから直接取得することをおすゝめします。直接取得できない場合は、CSVファイルへエクスポートするなどの方法を取ってください。  
　  

## チケットの項目
今回用いるRedmineのバグチケットの項目を簡単に説明してます。基本的な項目のみが用意されています。実際は因子型になっている項目をここでは文字型として扱っている点に注意してください。  
　  　  

項目             | 概要                             | データ型
-----------------|----------------------------------|-----------------
\#               | 識別番号（Primary Key）          | 整数型
プロジェクト     | 属するプロジェクト               | 文字型（因子型）
トラッカー       | 大分類                           | 文字型（因子型）
親チケット       | 親子関係を定義したい場合に用いる | 文字型
ステータス       | 対応状況                         | 文字型（因子型）
優先度           | 対応優先度                       | 文字型（因子型）
題名             | タイトル                         | 文字型
作成者           | 作成者                           | 文字型（因子型）
担当者           | 対応担当者                       | 文字型（因子型）
更新日           | 更新日時                         | 日時型（POSIXct）
カテゴリ         | 分類（任意に利用設定できる）     | 文字型（因子型）
対象バージョン   | チケット対処したバージョン       | 文字型
開始日           | 対応を開始した日                 | 日付型
期日             | 対応予定期間                     | 日付型
予定工数         | 対応予定工数                     | 数値型
進捗率           | 対応の進捗率                     | 数値型（%表記）
作成日           | 作成日時                         | 日時型（POSIXct）
終了日           | 対応完了日時                     | 日時型（POSIXct）
関連するチケット | 関係するチケット番号             | 文字型
Resolution       | 解決結果（非標準）               | 文字型（因子型）
Affected version | 影響のあるバージョン             | 文字型
説明             | 詳細                             | 文字型

<!-- #	Project	Tracker	Parent task	Status	Priority	Subject	Author	Assignee	Updated	Category	Target version	Start date	Due date	Estimated time	% Done	Created	Closed	Related issues -->

　  

## チケットデータ
実際のデータは以下のような四千レコード弱のデータです。  
　  

```{r}
(redmine <- "./data/redmine.csv" %>% 
  readr::read_csv(local = locale(encoding = "UTF-8")))
```

　  

## 分析のための前処理
分析に必要な前処理を行っておきます。作成日と終了日のデータは実際は日時データになっていますので日データに変換して、必要な項目のみを抽出しておきます。  
　  

```{r}
(x <- redmine %>% 
  dplyr::select(no = `#`, tracker = `トラッカー`, status = `ステータス`,
                priority = `優先度`, category = `カテゴリ`,
                version = `対象バージョン`, affected = `Affected version`, 
                open = `作成日`, close = `終了日`, subject = `題名`,
                assignee = `担当者`) %>% 
  dplyr::mutate(open = lubridate::date(open), close = lubridate::date(close)))
```

　  
データの概要は以下の通りです。  
　  

```{r, comment=""}
summary(x)
```

　  

# チケットの集計
データフレームに対する集計を行うには`dplyr::group_by`関数＋`dplyr::summarise`関数または`dplyr::count`関数を用いるのが便利です。  
　  
なお、以下の二つのコードは共に`data`に含まれる`key`変数の水準毎に個数を数えるもので結果は等価になります。  
　  

```
dplyr::group_by(data, key) %>% 
  dplyr::summarise(n = n())
```

```
dplyr::count(data, kye)
```

　  

## 単純集計
単純集計は一つの変数に対して集計を行います。  
　  

### Tracker
```{r}
x %>% 
  dplyr::count(tracker)
```

　  

### Status 
```{r}
x %>% 
  dplyr::count(status)
```

　  

### Priority
```{r}
x %>% dplyr::count(priority)
```

　  

### Category
```{r}
x %>% 
  dplyr::count(category)
```

　  

### Version
```{r}
x %>% 
  dplyr::count(version)
```

　  

### Affected
```{r}
x %>% 
  dplyr::count(affected)
```

　  

### Open
```{r}
x %>% 
  dplyr::count(open)
```

　  

## クロス集計
単純集計では見えにくい傾向はクロス集計を行いことで見えてくることもあります。クロス集計は`dplyr::count`関数または`dplyr::group_by`関数に複数の変数を指定し、`tidyr::spread`関数で変形することで簡単にクロス集計表が作成できます。  

```
dplyr::count(x, key1, key2) %>% 
  tidyr::spread(key = key1, value = n)
```

　  

### Tracker and Status
```{r}
x %>% 
  dplyr::count(tracker, status) %>% 
  tidyr::spread(key = tracker, value = n)
```

　  

### Tracker and Priority
大半のチケットがステータスが`Closed`な対応が完了しているチケットですので、`Closed`を除くチケットに対する優先度を見て見ます。  
　  

```{r}
x %>% 
  dplyr::filter(status != "Closed") %>% 
  dplyr::count(tracker, priority) %>% 
  tidyr::spread(key = tracker, value = n)
```

　  

### Priority and Status

#### Defectチケット
```{r}
x %>% 
  dplyr::filter(status != "Closed" & tracker == "Defect") %>% 
  dplyr::count(priority, status) %>% 
  tidyr::spread(key = priority, value = n)
```

　  

#### Patchチケット
```{r}
x %>% 
  dplyr::filter(status != "Closed" & tracker == "Patch") %>% 
  dplyr::count(priority, status) %>% 
  tidyr::spread(key = priority, value = n)
```

#### 対象レコードの抽出
クロス集計の結果優先度が`Urgent`であるチケットがあることが分かりましたので、対象が何かを表示させてみます。クロス集計で検索条件が分かっていますので絞り込むだけです。  
　  

```{r}
x %>% 
  dplyr::filter(status != "Closed" & tracker == "Defect") %>% 
  dplyr::filter(priority == "Urgent") %>% 
  dplyr::select(no, tracker, status, subject, assignee)
```

　  

### Priority and Category
```{r}
x %>% 
  dplyr::filter(status != "Closed" & tracker == "Defect") %>% 
  dplyr::count(category, priority) %>% 
  tidyr::spread(key = priority, value = n)
```

　  

### Priority and Assignee
```{r}
x %>% 
  dplyr::filter(status != "Closed" & tracker == "Defect") %>% 
  dplyr::count(priority, assignee) %>% 
  tidyr::spread(key = priority, value = n)
```

　  
このデータでは`Urgent`なチケットに担当者が割り当てられていないことが分かります。  
　  

## 期間集計
ある一定期間ごとに集計する場合は日時データを日、週、月、四半期、年などに変換し変換後のデータを`dplyr::count`関数で集計することで期間の変化を確認できるようになります。  
　  

### 日次集計
日次で集計する場合は日時の場合は`lubridate::date`関数で日付に変換しておきます。データがない日は集計対象外となります。稼働が発生していてデータがないのか、稼働が発生していないからデータがないのかで意味が変わってきますので集計の際には注意してください。  
　  

#### 起票されたチケットの推移
```{r}
x %>% 
  dplyr::filter(open >= "2018-1-1") %>% 
  dplyr::mutate(flag = ifelse(is.na(open), 0, 1)) %>% 
  dplyr::group_by(open) %>% 
  dplyr::summarise(ticket = sum(flag)) %>% 
  dplyr::arrange(open) %>% 
  dplyr::mutate(`累計` = cumsum(ticket),
                `前日との差` = ticket - dplyr::lag(ticket))
```

　  

### 週次集計
"週"を求めるには`lubridate::week`関数を用います。ただし、`lubridate::week`関数は1から53までの値しか返しませんので、年をまたぐ際は`lubridate::year`関数などを用いて年の識別ができるようにしてください。  
　  

#### 起票されたチケットの推移
```{r}
x %>% 
  dplyr::filter(open >= "2018-1-1") %>% 
  dplyr::mutate(week = lubridate::week(open)) %>% 
  dplyr::mutate(flag = ifelse(is.na(open), 0, 1)) %>% 
  dplyr::group_by(week) %>% 
  dplyr::summarise(ticket = sum(flag)) %>% 
  dplyr::arrange(week) %>% 
  dplyr::mutate(`累計` = cumsum(ticket),
                `前週との差` = ticket - dplyr::lag(ticket))
```

　  

#### 完了したチケットの推移
```{r}
x %>% 
  dplyr::filter(close >= "2018-1-1") %>% 
  dplyr::mutate(week = lubridate::week(close)) %>% 
  dplyr::mutate(flag = ifelse(is.na(close), 0, 1)) %>% 
  dplyr::group_by(week) %>% 
  dplyr::summarise(ticket = sum(flag)) %>% 
  dplyr::arrange(week) %>% 
  dplyr::mutate(`累計` = cumsum(ticket),
                `前週との差` = ticket - dplyr::lag(ticket))
```

　  

### 月次集計
"月"を求めるには`lubridate::month`関数を用います。ただし、`lubridate::month`関数は1から12までの値しか返しませんので、年をまたぐ際は`lubridate::year`関数などを用いて年の識別ができるようにしてください。  
　  

#### 起票されたチケットの推移
```{r}
x %>% 
  dplyr::filter(open >= "2018-1-1") %>% 
  dplyr::mutate(month = lubridate::month(open)) %>% 
  dplyr::mutate(flag = ifelse(is.na(open), 0, 1)) %>% 
  dplyr::group_by(month) %>% 
  dplyr::summarise(ticket = sum(flag)) %>% 
  dplyr::arrange(month) %>% 
  dplyr::mutate(`累計` = cumsum(ticket),
                `前月との差` = ticket - dplyr::lag(ticket))
```

　  

### 四半期次集計
"四半期"を求めるには`lubridate::quarter`関数を用います。年をまたぐ際は`with_year`オプションを使用すると年の識別ができるようになります。また、第一四半期が1月以外から始まる場合は`fiscal_start`オプションを使用してください。  
　  

#### 起票されたチケットの推移
```{r}
x %>% 
  dplyr::mutate(quarter = lubridate::quarter(open, with_year = TRUE,
                                             fiscal_start = 1)) %>% 
  dplyr::mutate(flag = ifelse(is.na(open), 0, 1)) %>% 
  dplyr::group_by(quarter) %>% 
  dplyr::summarise(ticket = sum(flag)) %>% 
  dplyr::arrange(quarter) %>% 
  dplyr::mutate(`累計` = cumsum(ticket),
                `前四半期との差` = ticket - dplyr::lag(ticket))
```

　  

### 年次集計
"年"を求めるには`lubridate::year`関数を用います。  
　  

#### 起票されたチケットの推移
```{r}
x %>% 
  dplyr::mutate(year = lubridate::year(open)) %>% 
  dplyr::mutate(flag = ifelse(is.na(open), 0, 1)) %>% 
  dplyr::group_by(year) %>% 
  dplyr::summarise(ticket = sum(flag)) %>% 
  dplyr::arrange(year) %>% 
  dplyr::mutate(`累計` = cumsum(ticket),
                `前年との差` = ticket - dplyr::lag(ticket))
```

　  

# チケットの可視化

　  

## 分布の可視化
分布を可視化する代表的な方法としてはヒストグラム、箱ひげ図などがあります。  
　  

## 集計の可視化
集計結果を可視化する方法としては棒グラフ、円グラフ、それらの層別グラフなどがあります。  
　  

### Priority vs Category, Open Tickets
```{r}
x %>% 
  dplyr::filter(status != "Closed" & tracker == "Defect") %>% 
  dplyr::mutate(year = lubridate::year(open)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = priority, fill = category)) + 
    ggplot2::geom_bar(alpha = 0.5) + 
    ggplot2::facet_wrap(~ year)
```

　  

### Priority vs Category, Closed Tickets
```{r}
x %>% 
  dplyr::filter(status == "Closed" & tracker == "Defect") %>% 
  dplyr::mutate(year = lubridate::year(close)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = priority, fill = category)) + 
    ggplot2::geom_bar(alpha = 0.5) + 
    ggplot2::facet_wrap(~ year)
```

　  

### Affected vs Status
バージョンごとのチケットの完了状況をチケット起票年ごとに分けて表示することで過去バグと最近のバグの発生状況を俯瞰できるようになります。  
　  

```{r}
x %>% 
  dplyr::filter(tracker == "Defect") %>% 
  dplyr::mutate(flag = ifelse(status == "Closed", "Closed", "Open")) %>% 
  dplyr::mutate(year = lubridate::year(open)) %>% 
  dplyr::filter(!is.na(affected)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = affected, fill = flag)) + 
    ggplot2::geom_bar(alpha = 0.75) + 
    ggplot2::facet_wrap(~ year)
```

　  

## 推移の可視化
推移を可視化する代表的な方法としては折れ線グラフ、棒グラフがあります。  
　  

### 四半期枚の完了チケット数
```{r}
x %>% 
  dplyr::mutate(quarter = lubridate::quarter(close, with_year = TRUE,
                                             fiscal_start = 1)) %>% 
  dplyr::mutate(flag = ifelse(is.na(open), 0, 1)) %>% 
  dplyr::group_by(quarter, priority) %>% 
  dplyr::summarise(ticket = sum(flag)) %>% 
  dplyr::arrange(quarter) %>% 
  dplyr::filter(!is.na(quarter)) %>% 
  dplyr::mutate(`累計` = cumsum(ticket),
                `前四半期との差` = ticket - dplyr::lag(ticket)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = as.character(quarter))) + 
    ggplot2::geom_bar(ggplot2::aes(y = ticket, fill = priority),
                      stat = "identity", alpha = 0.5)
```

　  

### 週次傾向の可視化
前出の週次集計を可視化してみます。加えて平均起票数を基準として前週との起票数の差を折れ線グラフで表示しています。  
　  

#### 起票されたチケットの推移
```{r}
open <- x %>% 
  dplyr::filter(open >= "2018-1-1") %>% 
  dplyr::mutate(week = lubridate::week(open)) %>% 
  dplyr::mutate(flag = ifelse(is.na(open), 0, 1)) %>% 
  dplyr::group_by(week) %>% 
  dplyr::summarise(open = sum(flag)) %>% 
  dplyr::arrange(week) %>% 
  dplyr::mutate(cumopen = cumsum(open), diff = open - dplyr::lag(open))

open %>% 
  dplyr::mutate(diff_offset = diff + round(mean(open, na.rm = TRUE))) %>% 
  ggplot2::ggplot(ggplot2::aes(x = week)) +
    ggplot2::geom_bar(ggplot2::aes(y = open), stat = "identity", alpha = 0.25) + 
    ggplot2::geom_hline(yintercept = round(mean(open$open, na.rm = TRUE)),
                        colour = "#00bfc4", linetype = "dashed") + 
    ggplot2::geom_line(ggplot2::aes(y = diff_offset), colour = "#00bfc4",
                       size = 0.75)
```

　  

#### 完了したチケットの推移
```{r}
close <- x %>% 
  dplyr::filter(close >= "2018-1-1") %>% 
  dplyr::mutate(week = lubridate::week(close)) %>% 
  dplyr::mutate(flag = ifelse(is.na(close), 0, 1)) %>% 
  dplyr::group_by(week) %>% 
  dplyr::summarise(close = sum(flag)) %>% 
  dplyr::arrange(week) %>% 
  dplyr::mutate(cumclose = cumsum(close), diff = close -dplyr::lag(close))

close %>% 
  dplyr::mutate(diff_offset = diff + round(mean(close, na.rm = TRUE))) %>% 
  ggplot2::ggplot(ggplot2::aes(x = week)) +
    ggplot2::geom_bar(ggplot2::aes(y = close), stat = "identity", alpha = 0.25) + 
    ggplot2::geom_hline(yintercept = round(mean(close$close, na.rm = TRUE)),
                        colour = "#f8766d", linetype = "dashed") + 
    ggplot2::geom_line(ggplot2::aes(y = diff_offset), colour = "#f8766d",
                       size = 0.75)
```

　  

### オープン・クローズチャート
前出の週次の集計から累計データに着目したものがオープン・クローズチャートです。オープン・クローズチャートはチケットの対応状況が一目で分かるグラフです。
　  

```{r}
open_ticket <- open %>% 
  dplyr::full_join(close, by = "week") %>% 
  dplyr::select(week, open, close) %>%
  tidyr::gather(key, value, -week)

open %>% 
  dplyr::full_join(close, by = "week") %>% 
  dplyr::select(week, cumopen, cumclose) %>%
  tidyr::gather(key, value, -week) %>% 
  dplyr::left_join(open_ticket, by = "week") %>% 
  ggplot2::ggplot(ggplot2::aes(x = week)) + 
    ggplot2::geom_bar(ggplot2::aes(y = value.y, fill = key.y),
                      stat = "identity", alpha = 0.5, position = "dodge") +
    ggplot2::geom_line(ggplot2::aes(y = value.x, colour = key.x),
                       stat = "identity", size = 0.75) + 
    ggplot2::scale_color_hue(name = "累計",
                             labels = c(cumclose = "Closed", cumopen = "Open")) +
    ggplot2::scale_fill_hue(name = "週次",
                            labels = c(close = "Closed", open = "Open"))
```

　  

## 滞留期間の可視化
優先度ごとにチケットがどれだけ滞留されているか可視化してみます。  
　  

```{r}
x %>% 
  dplyr::filter(open >= "2018-1-1") %>% 
  dplyr::filter(status != "Closed") %>% 
  dplyr::mutate(days = lubridate::today() - open + 1) %>% 
  dplyr::group_by(priority) %>% 
  dplyr::summarise(min = min(days), med = median(days), max = max(days))

x %>% 
  dplyr::filter(open >= "2018-1-1") %>% 
  dplyr::filter(status != "Closed") %>% 
  dplyr::mutate(days = lubridate::today() - open + 1) %>% 
  ggplot2::ggplot(ggplot2::aes(x = priority, y = days)) + 
    ggplot2::geom_boxplot()
```

　  
同様にカテゴリごとの滞留期間を可視化してみます。
```{r}
x %>% 
  dplyr::filter(open >= "2018-1-1") %>% 
  dplyr::filter(status != "Closed") %>% 
  dplyr::mutate(days = lubridate::today() - open + 1) %>% 
  dplyr::group_by(category) %>% 
  dplyr::summarise(min = min(days), med = median(days), max = max(days),
                   mode = which.max(table(days)))

x %>% 
  dplyr::filter(open >= "2018-1-1") %>% 
  dplyr::filter(status != "Closed") %>% 
  dplyr::mutate(days = lubridate::today() - open + 1) %>% 
  ggplot2::ggplot(ggplot2::aes(x = category, y = days)) + 
    ggplot2::geom_boxplot()
```

滞留期間のヒストグラム
　  

## 対処期間の可視化
カテゴリごとのチケット対処期間（開始日から終了日までの期間）を可視化してみます。  
　  

```{r}
x %>% 
  dplyr::filter(status == "Closed") %>% 
  dplyr::mutate(days = close - open + 1) %>% 
  dplyr::group_by(category) %>% 
  dplyr::summarise(min = min(days), med = median(days), max = max(days),
                   mode = which.max(table(days)))
  
x %>% 
  dplyr::filter(status == "Closed") %>% 
  dplyr::mutate(days = close - open + 1) %>% 
  ggplot2::ggplot(ggplot2::aes(x = category, y = days)) + 
    ggplot2::geom_boxplot()
```

　  



## 対処推移の可視化
チケットのオープン数とクローズ数の推移を可視化してみます。データ数が多いので2018年4月1日以降のチケットのみを対象としています。  
　  

```{r}
df_date <- seq(from = range(x$open)[1], to = range(x$open)[2], by = 1) %>%
  as.data.frame()
names(df_date) <- c("Date")
df_date <- df_date %>% 
  dplyr::filter(Date >= "2018-4-1")

open <- x %>% 
  dplyr::select(ID = no, Tracker = tracker, Status = status,
                OpenDateTime = open, CloseDateTime = close) %>% 
  dplyr::mutate_at(vars(Status),
                   funs(replace(., (. != "Closed"), "Open"))) %>% 
  dplyr::filter(Tracker == "Defect" & Status != "Closed") %>% 
  dplyr::mutate(Date = dplyr::if_else(Status == "Closed", 
                                      lubridate::as_date(CloseDateTime),
                                      lubridate::as_date(OpenDateTime))) %>% 
  dplyr::arrange(Date) %>% 
  dplyr::count(Date, Status) %>% 
  dplyr::right_join(df_date, by = "Date") %>% 
  dplyr::mutate_at(vars(n), funs(replace(., is.na(.), 0))) %>% 
  dplyr::mutate_at(vars(Status), funs(replace(., is.na(.), "Open"))) %>% 
  dplyr::mutate(Cumsum = cumsum(n))

closed <- x %>% 
  dplyr::select(ID = no, Tracker = tracker, Status = status,
                OpenDateTime = open, CloseDateTime = close) %>% 
  dplyr::mutate_at(vars(Status),
                   funs(replace(., (. != "Closed"), "Open"))) %>% 
  dplyr::filter(Tracker == "Defect" & Status == "Closed") %>% 
  dplyr::mutate(Date = dplyr::if_else(Status == "Closed", 
                                      lubridate::as_date(CloseDateTime),
                                      lubridate::as_date(OpenDateTime))) %>% 
  dplyr::arrange(Date) %>% 
  dplyr::count(Date, Status) %>% 
  dplyr::right_join(df_date, by = "Date") %>% 
  dplyr::mutate_at(vars(n), funs(replace(., is.na(.), 0))) %>% 
  dplyr::mutate_at(vars(Status), funs(replace(., is.na(.), "Closed"))) %>% 
  dplyr::mutate(Cumsum = cumsum(n))

open %>% 
  dplyr::bind_rows(closed) %>% 
  dplyr::arrange(Date) %>% 
  ggplot2::ggplot(ggplot2::aes(x = Date, y = Cumsum)) +
    # ggplot2::geom_area(aes(fill = Status), alpha = 0.5, position = "stack")
    # ggplot2::geom_area(aes(fill = Status), alpha = 0.5, position = "identity") +
    ggplot2::geom_line(ggplot2::aes(colour = Status)) +
    # ggplot2::geom_smooth(ggplot2::aes(colour = Status)) +
    ggplot2::geom_bar(ggplot2::aes(y = n, fill = Status), stat = "identity") + 
    ggplot2::labs(x = "days", y = "Number of tickets",
                  title = "Open - Closed Chart") + 
    NULL
```


# Tips
## 集計を加える
```{r}
row_sum <- x %>% 
  dplyr::count(tracker, status) %>% 
  tidyr::spread(key = tracker, value = n) %>% 
  dplyr::mutate(Sum = ifelse(is.na(Defect), 0, Defect) + 
                  ifelse(is.na(Patch), 0, Patch)) %>% 
  dplyr::summarise_if(is.numeric, sum, na.rm = TRUE) %>% 
  dplyr::mutate(status = NA) %>% 
  dplyr::select(status, Defect, Patch, Sum)

x %>% 
  dplyr::count(tracker, status) %>% 
  tidyr::spread(key = tracker, value = n) %>% 
  dplyr::mutate(Sum = ifelse(is.na(Defect), 0, Defect) + 
                  ifelse(is.na(Patch), 0, Patch)) %>% 
  dplyr::bind_rows(row_sum)
```

# 参考資料

* [チケット計測のススメ <i class="fa fa-external-link"></i>](https://qiita.com/kawahira/items/0196c315642f4a72458f){target="_blank" title=""}
* [redmine.tokyo 第10回勉強会に行ってきた <i class="fa fa-external-link"></i>](http://yassan.hatenablog.jp/entry/study-redmine-20160514){target="_blank" title=""}
　  

---

<!-- Footer -->
```{r child="../shared/footer.Rmd"}
```