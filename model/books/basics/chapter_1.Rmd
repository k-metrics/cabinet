---
title: "第1章 本文"
output: 
  html_document:  
    number_section: no
---

<!-- Include Common Links -->
```{r chapter_1, child="../../../common/links.Rmd"}
```

```{r setup, include=FALSE}
# 共通chunkオプションの指定
knitr::opts_chunk$set(warning = FALSE, echo = TRUE)

# データハンドリングで利用する外部パッケージの読み込み
require(tidyverse)
# 表示で利用する外部パッケージの読み込み
require(gridExtra)
require(DT)
require(knitr)
tidyverse::tidyverse_conflicts()

# ローカル定義関数の読み込み
source("../../../common/common.R")
```

# はじめに {.unnumbered}
本資料は『[改訂版 日本統計学会公式認定 統計検定2級対応　統計学基礎](http://www.tokyo-tosho.co.jp/books/978-4-489-02227-2/)』（以降、テキスト）をRを用いて紐解いていく際の例を示したものですのでテキストと合わせてお読みください。また、本資料で使用しているデータの入手に関してはテキストにてご確認ください。

# データの記述と要約
## 変数の分類
#### 質的変数と量的変数 {.unnumbered}
```{r}
x <- read.csv(file = "./data/1章/本文/room.csv", fileEncoding = "CP932")

x %>% 
  df_print(caption = "表1.1　賃貸マンションデータ")
```
　  

Rでデータを読み込むとデフォルトでは文字データは因子（Factor）すなわち質的変数として読み込まれ、数値データは文字取り量的変数として読み込まれます。ただし、フラグ（0と1）のようなデータでも量的変数として読み込まれますので、必要に応じて質的変数（因子）に変換してください。
```{r}
str(x)
listviewer::jsonedit(x)
```
　  

表1.1のデータを要約すると量的変数は代表値として質的変数は度数として要約されますので、下記のようになりおおまかなデータ分布が把握できます。
```{r}
summary(x) %>% df_print()
```

## 量的データの分布
### ヒストグラムの作成
#### 度数分布表 {.unnumbered}
ダウンロードデータには度数分布表を作成するRのコードがありませんが、度数分布表を作成するには`cut`関数を用いるのが便利です。`dplyr`パッケージと組み合わせてデータフレーム型になるようにするとその後の分析が便利になります。度数分布表には表1.4では示されていない累積度数分布を算出することもありますので、一例として計算してあります。  
なお、下記の度数分布表では家賃の階級幅をスタージェスの公式を用いて算出していますが、偶然にも表1.4と同じ1万円の階級幅になっています。
```{r}
x %>% 
  dplyr::mutate(rent = round(家賃/1000)) %>% 
  dplyr::mutate(bin.w = cut(rent, breaks(rent))) %>% 
  dplyr::select(bin.w, rent) %>% 
  dplyr::group_by(bin.w) %>% 
  dplyr::summarise(freq = n()) %>%
  dplyr::mutate(cum = cumsum(freq), rel = round(freq/sum(freq), 2),
                cum_rel = cumsum(rel)) %>% 
  dplyr::rename('家賃[千円]' = bin.w, '度数' = freq, '相対度数' = rel,
                '累積度数' = cum, '累積相対度数' = cum_rel) %>% 
  df_print(caption = "度数分布表")
```

#### ヒストグラム {.unnumbered}
図1.1のヒストグラムを描くには前述の度数分布表を元に描くのですが、Rでは度数分布表を求めなくても関数一つでヒストグラムをはじめとしたグラフを描くことができます。これは他の言語にはないRの特徴であり利点です。
ダウンロードデータでは標準の`hist`関数を用いていますが、ここでは`ggplot2`パッケージを用います。
```{r}
breaks <- with(x, breaks(家賃))

x %>% 
  dplyr::rename(rent = 家賃) %>% 
  ggplot2::ggplot(aes(x = rent)) +
    ggplot2::geom_histogram(breaks = breaks, closed = "right") +
    ggplot2::xlab("家賃[円]") + ylab("度数") +
    ggplot2::ggtitle("家賃のヒストグラム",
                     subtitle = paste("階級幅 = ", diff(breaks), "円", sep = ""))
```

#### 階級幅を変えたヒストグラム {.unnumbered}
```{r}
breaks <- with(x, pretty(range(家賃), n = nclass.Sturges(家賃)*2))
gg1 <- x %>% 
  dplyr::rename(rent = 家賃) %>% 
  ggplot2::ggplot(aes(x = rent)) +
    ggplot2::geom_histogram(breaks = breaks, closed = "right") +
    ggplot2::xlab("家賃[円]") + ylab("度数") +
    ggplot2::ggtitle("家賃のヒストグラム",
                     subtitle = paste("階級幅 = ", diff(breaks), "円", sep = ""))

breaks <- with(x, pretty(range(家賃), n = nclass.Sturges(家賃)/2))
gg2 <- x %>% 
  dplyr::rename(rent = 家賃) %>% 
  ggplot2::ggplot(aes(x = rent)) +
    ggplot2::geom_histogram(breaks = breaks, closed = "right") +
    ggplot2::xlab("家賃[円]") + ylab("度数") +
    ggplot2::ggtitle("家賃のヒストグラム",
                     subtitle = paste("階級幅 = ", diff(breaks), "円", sep = ""))

gridExtra::grid.arrange(gg1, gg2, ncol = 2)
```

#### 累積分布図 {.unnumbered}
```{r}
x %>% 
  ggplot2::ggplot(aes(家賃)) +
    ggplot2::stat_ecdf() +
    ggplot2::ylab("累積相対度数") +
    ggplot2::ggtitle("家賃の累積分布図")
```

#### ローレンツ曲線 {.unnumbered}
Rでローレンツ曲線を描くには`ineq`パッケージを使うのが最も簡単です。累積相対度数を求めなくても描くことが可能です。また、ジニ係数も簡単に求められます。
```{r, message=FALSE}
require(ineq)
Lc(c(100, 100, 200, 300, 300), plot = TRUE)
Gini(c(100, 100, 200, 300, 300))
```

`ggplot2`ではローレンツ曲線を描く関数は用意されていないので、描くためのデータを作成する必要があります。データを作成する際にはX軸が0の際のY軸のデータ0を用意する点に注意してください。以下の例はtidyでないデータを使っていますが、実際にはtidyなデータを使う方がベターです。
```{r}
# データの作成
lc <- data.frame(e  = c(0, 0.2, 0.4, 0.6, 0.8, 1.0),
                 c1 = c(0, 200, 200, 200, 200, 200),
                 c2 = c(0, 100, 100, 200, 300, 300),
                 c3 = c(0,   0,   0, 100, 100, 300))

# 累積相対度数を作成して作図
lc %>% 
  dplyr::mutate(y1 = cumsum(c1)/sum(c1), y2 = cumsum(c2)/sum(c2),
                y3 = cumsum(c3)/sum(c3)) %>% 
  ggplot2::ggplot(aes(x = e)) +
    ggplot2::geom_abline(slope = 1, intercept = 0, colour = "green") +
    ggplot2::geom_line(aes(y = y1), linetype = "longdash") +
    ggplot2::geom_line(aes(y = y2), linetype = "dashed") +
    ggplot2::geom_line(aes(y = y3), linetype = "dotted") +
    ggplot2::xlab("従業員の累積相対度数") + ylab("給与の累積相対度数") +
    ggplot2::ggtitle("ローレンツ曲線の例")
```

## 分布の特徴を表す指標
### 平均・分散・標準偏差
```{r}
x_mean <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(s_mean(., 1)))

x_var <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(s_var(., 1)))

x_sd <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(s_sd(., 1)))

x_tbl <- dplyr::bind_rows(x_mean, x_var, x_sd)
row.names(x_tbl) <- c("平均値", "標本分散", "標準偏差")

df_print(x_tbl, caption = "各変数の特徴量")
```

### 標準化得点（Zスコア）
Rで標準化得点（Zスコア）を求めるには`scale`関数を利用するのが最も簡単です。
```{r}
x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::mutate_each(funs(scale)) %>% 
  df_print(caption = "各量的変数の標準化得点（Zスコア）")
```

### 変動係数
変動係数は標準偏差を平均値で割ったもの（標準化したもの）です。
```{r}
x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_each(funs(sd(.)/mean(.))) %>% 
  df_print(caption = "変動係数")
```

### 中央値・最頻値
中央値は第２四分位値と同じです。また、Rでは最頻値を求める関数はありません。
```{r}
x_med <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(median))

x_qt <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(quantile(., 0.5)))

x_tbl <- dplyr::bind_rows(x_med, x_qt)
row.names(x_tbl) <- c("中央値", "第二四分位値")

df_print(x_tbl, caption = "中央値")
```

#### Rで最頻値を計算する方法
Rで最頻値を計算するにはクロス集計に使う`table`関数を用います。
```{r}
x$家賃 %>% 
  table() %>% t() %>% as.data.frame() %>% top_n(1, Freq) %>%
  select(-Var1) %>% df_print(caption = "家賃の最頻値")

x$大きさ %>% 
  table() %>% t() %>% as.data.frame() %>% top_n(1, Freq) %>% 
  select(-Var1) %>% df_print(caption = "大きさの最頻値")

x$築年数 %>% 
  table() %>% t() %>% as.data.frame() %>% top_n(1, Freq) %>% 
  select(-Var1) %>% df_print(caption = "築年数の最頻値")
```

`dplyr`パッケージだけで集計することも可能です。
```{r}
x %>% 
  dplyr::count(家賃) %>% 
  dplyr::arrange(desc(n)) %>% 
  dplyr::top_n(n = 1) %>% 
  df_print(caption = "家賃の最頻値")
```


### 範囲・四分位範囲
```{r}
x_min <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(min))

x_max <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(max))

x_diff <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(diff(range(.))))

x_1qt <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(quantile(., 0.25)))

x_3qt <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_all(funs(quantile(., 0.75)))

x_iqr <- x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>% 
  dplyr::summarise_each(funs(IQR))

x_tbl <- dplyr::bind_rows(x_min, x_max, x_diff, x_1qt, x_3qt, x_iqr)
row.names(x_tbl) <- c("最小値", "最大値", "範囲", "第一四分位値", "第三四分位値",
                      "IQR")
df_print(x_tbl, caption = "範囲と四分位範囲")
```

## 量的データの要約とグラフ表現
### 五数要約
前述の最小値、第一四分位値、第二四分位値（中央値）、第三四分位値、最大値の五数を求めるにはRでは`fivenum`関数を用います。
```{r}
data.frame('家賃' = fivenum(x$家賃), '大きさ' = fivenum(x$大きさ),
           '築年数' = fivenum(x$築年数),
           row.names = c("最小値", "第一四分位値", "中央値", "第三四分位値",
                         "最大値")) %>% 
  df_print(caption = "量的変数の五数要約")
```

### 箱ひげ図
Rで描く箱ひげ図は図1.14,15とは異なりひげ（whisker）は最大値と最小値を意味しません。また、`ggplot2`パッケージで描ける箱ひげ図にはひげ（whisker）はありません。
```{r}
x %>% 
  dplyr::select(x = 近さ, y = 家賃) %>% 
  ggplot2::ggplot(aes(x, y)) +
    ggplot2::geom_boxplot() +
    ggplot2::xlab("近さ") + ggplot2::ylab("家賃[円]")
```

### 外れ値
Rで描く箱ひげ図では外れ値が表示される場合があります。
```{r}
x %>% 
  dplyr::select(家賃, 大きさ, 築年数) %>%
  dplyr::mutate(家賃 = 家賃/10000) %>% 
  dplyr::rename('家賃[万円]' = 家賃, '大きさ[平米]' = 大きさ) %>% 
  tidyr::gather() %>% 
  ggplot2::ggplot(aes(x = key, y = value)) + 
    ggplot2::geom_boxplot() +
    ggplot2::xlab("") + ylab("")
```

## 質的データの度数分布とグラフ表現
#### 棒グラフ {.unnumbered}
質的変数の度数を表現する場合はヒストグラムでなく棒グラフを使います。
```{r}
x %>% 
  dplyr::count(間取り) %>% 
  df_print(caption = "間取りごとの度数")

x %>% 
  ggplot2::ggplot(aes(x = 間取り, fill = 間取り)) +
    ggplot2::geom_bar(alpha = 0.5) +
    ggplot2::theme(legend.position = "none")
```

#### 円グラフ {.unnumbered}
`ggplot2`パッケージにおける円グラフは積み上げ棒グラフを描いて、から座標軸を同心円状にすることで描きます。
```{r}
x %>% 
  dplyr::count(方角) %>% 
  df_print(caption = "方角ごとの度数")

x %>% 
  dplyr::count(方角) %>% 
  ggplot2::ggplot(aes(x = "", y = n, fill = 方角)) +
    ggplot2::geom_bar(alpha = 0.5, width = 1, stat = "identity") +
    ggplot2::coord_polar("y", direction = -1) +
    ggplot2::xlab("") + ylab("")
```


## 2変数データの記述と要約
### 散布図
```{r}
x %>% 
  dplyr::select(大きさ, 家賃, 近さ) %>% 
  ggplot2::ggplot(aes(x = 大きさ, y = 家賃)) +
    ggplot2::geom_point(aes(shape = 近さ, colour = 近さ), size = 2)
```

#### クロス集計表
Rでクロス集計を行うには`table`関数が便利ですが`dplyr`パッケージと`tidyr`パッケージを用いても作成できます。
```{r}
x %>% 
  dplyr::rename(rent = 家賃, size = 大きさ) %>% 
  dplyr::mutate(rent = rent/1000,
                # rent_bin = cut(rent, pretty(range(rent), n = nclass.Sturges(rent))),
                # size_bin = cut(size, pretty(range(size), n = nclass.Sturges(size)))) %>% 
                rent_bin = cut(rent, seq(60, 150, by = 10)),
                size_bin = cut(size, seq(10, 60, by = 5))) %>% 
  dplyr::count(rent_bin, size_bin) %>% 
  tidyr::spread(key = rent_bin, value = n) %>% 
  DT::datatable(caption = "部屋の大きさと家賃のクロス集計")
```

一方、`table`関数を用いた場合`addmargins`関数で合計欄を追加することが可能です。
```{r}
room <- x
label1 <- unique(cut(room$大きさ, seq(10, 60, by = 5)))
label2 <- unique(cut(room$家賃/1000, seq(60, 150, by = 10)))

addmargins(table(cut(room$大きさ, seq(10, 60, by = 5), labels = label1),
                 cut(room$家賃/1000, seq(60, 150, by = 10), labels = label2))) %>% 
  knitr::kable(caption = "`table`関数でのクロス集計表")
```

### 相関関係
Rで共分散を計算するには`cov`関数、相関係数を計算するには`cor`関数が標準で用意されています。無相関の検定には`cor.test`関数があります。どの関数も計算方法として"ピアソン"、"ケンドール"、"スピアマン"から選択できます。
```{r}
with(x, cov(大きさ, 家賃))
with(x, cor(大きさ, 家賃)) %>% round(2)
with(x, cor.test(大きさ, 家賃))
```

### 偏相関関係
Rで偏相関係数を計算するには`RcmdrMisc::partial.cor`という関数がありますが、これを使うには`RcmdrMisc`パッケージをインストールする必要があります。ただ。この関数は引数をマトリクス型で変数を指定する必要があるのですこしばかり厄介です。大きさ、家賃、築年数で偏相関係数を見てみます。
```{r}
x %>% 
  dplyr::select(大きさ, 家賃, 築年数) %>% 
  as.matrix() %>% 
  RcmdrMisc::partial.cor()
```

その他、`psych`パッケージの`psych::partial.r`関数を用いると制御変数（見かけ上の相関を生じさせている変数）を指定して偏相関係数を求めることが可能ですがこちらもマトリクス型で変数を指定する必要があります。以下では大きさを制御変数としています。
```{r}
x %>% 
  dplyr::select(大きさ, 家賃, 築年数) %>% 
  as.matrix() %>% 
  psych::partial.r(c(2, 3), c(1))
```

ただし`RcmdrMisc::partial.cor`や`psych::partial.r`では無相関検定ができませんので、偏相関係数の無相関検定を行うには`ppcor`パッケージを導入する必要があります。`ppcor::pcor.test`関数の引数は`psych:patial.r`関数と同じで三番目に制御変数を指定します。
```{r}
x %>% 
  dplyr::select(大きさ, 家賃, 築年数) %>% 
  with(., ppcor::pcor.test(家賃, 築年数, 大きさ)) %>% 
  knitr::kable(caption = "家賃と築年数の偏相関係数（大きさを制御変数とした場合）")
```

また、`RcmdrMisc::partial.cor`関数のような偏相関行列を出したい場合は`ppcor::pcor`関数を用います。
```{r}
x_pcor <- x %>% 
  dplyr::select(大きさ, 家賃, 築年数) %>% 
  ppcor::pcor()

x_pcor$estimate %>% knitr::kable(caption = "偏相関係数")
x_pcor$p.value %>% knitr::kable(caption = "p値")
x_pcor$statistic %>% knitr::kable(caption = "statistic")
```
　  

### 回帰直線
```{r}
x %>% 
  dplyr::select(size = 大きさ, fee = 家賃, age = 築年数) %>% 
  ggplot2::ggplot(aes(x = size, y = fee)) +
    ggplot2::geom_point() + 
    ggplot2::geom_smooth(method = "lm", se = FALSE) +
    ggplot2::xlab("大きさ") + ggplot2::ylab("家賃") +
    ggplot2::ggtitle("家賃と大きさの相関関係")

x %>% 
  select(大きさ, 家賃, 築年数) %>% 
  with(., ppcor::pcor.test(家賃, 大きさ, 築年数)) %>% 
  knitr::kable(caption = "家賃と大きさの偏相関係数")
```

回帰分析とその結果の確認は下記の通りです。
```{r}
summary(lm(家賃 ~ 大きさ, data = x))

oldpar <- par()
par(mfrow = c(2, 2))
plot(lm(家賃 ~ 大きさ, data = x))
par(oldpar)
```

### 質的データのクロス集計表
```{r}
# Windows版のdplyr::count, dplyr::group_byは変数(列名)が日本語だとエラーになる
# x %>% 
#   dplyr::mutate(高低 = ifelse(家賃 >= 100000, "高い", "安い"),
#                 狭広 = ifelse(大きさ >= 25, "広い", "狭い")) %>% 
#   dplyr::count(狭広, 高低) %>% 
#   tidyr::spread(key = 高低, value = n) %>% 
#   knitr::kable(caption = "家賃と大きさのクロス集計表")

x %>% 
  dplyr::mutate(fee = ifelse(家賃 >= 100000, "高い", "安い"),
                size = ifelse(大きさ >= 25, "広い", "狭い")) %>% 
  dplyr::count(size, fee) %>% 
  tidyr::spread(key = fee, value = n) %>% 
  dplyr::rename(狭広 = size) %>% 
  knitr::kable(caption = "家賃と大きさのクロス集計表")
```

```{r}
x %>% 
  dplyr::mutate(fee = ifelse(家賃 >= 100000, "高い", "安い")) %>% 
  dplyr::rename(nearness = 近さ) %>% 
  dplyr::count(nearness, fee) %>% 
  tidyr::spread(key = fee, value = n) %>% 
  dplyr::rename(近さ = nearness) %>% 
  knitr::kable(caption = "家賃と近さのクロス集計表")
```

クロス集計については残念ながらExcelの方に歩があります。
　  

## 時系列データの記述と簡単な分析

### 時系列データ
```{r}
x <- read.csv(file = "./data/1章/本文/death.csv", fileEncoding = "CP932")

x %>% 
  t() %>% as.data.frame() %>%
  knitr::kable(caption = "表1.18　交通事故死者数")

breaks <- seq(12, 22, by = 2)
labels <- as.character(breaks)

x %>% 
  tidyr::gather(key = '年齢区分', value = '死者数', -平成暦年) %>% 
  dplyr::rename(year = 平成暦年, range = 年齢区分, count = 死者数) %>% 
  ggplot(aes(x = year, group = range)) +
    ggplot2::geom_line(aes(y = count, colour = range, linetype = range)) +
    ggplot2::geom_point(aes(y = count, colour = range, shape = range),
                        size = 2) +
    ggplot2::scale_x_continuous(breaks = breaks, labels = labels) +
    ggplot2::xlab("平成[年]") + ggplot2::ylab("交通事故死者数") +
    ggplot2::ggtitle("年齢別24時間死者数の推移",
                     subtitle = "各年12月末")
```
　  

### 指数化と幾何平均
```{r}
x <- read.csv(file = "./data/1章/本文/Salary.csv", fileEncoding = "CP932")

x %>% 
  df_print(caption = "表1.19　一人平均月間現金給与総額データ")
```
　  

#### 指数化
上記のデータを2000年の平均給与を基準として指数化した場合
```{r}
x_base <- x %>% 
  dplyr::filter(Year < 200100) %>% 
  dplyr::select(All, Tokyo) %>% 
  dplyr::summarise_each(funs(mean))

knitr::kable(x_base, caption = "2000年の平均値")

breaks <- seq(1, length(x$Year), by = 12)
labels <- as.character(seq(2001, 2012, by = 1))

gg_all <- x %>% 
  dplyr::mutate(all = All/x_base$All, tokyo = Tokyo/x_base$Tokyo,
                year = row_number()) %>% 
  ggplot2::ggplot(aes(x = year)) +
    ggplot2::geom_line(aes(y = all)) +
    ggplot2::scale_x_continuous(breaks = breaks, labels = labels) +
    ggplot2::xlab("") + ggplot2::ylab("全国")

gg_tokyo <- x %>% 
  dplyr::mutate(all = All/x_base$All, tokyo = Tokyo/x_base$Tokyo,
                year = row_number()) %>% 
  ggplot2::ggplot(aes(x = year)) +
    ggplot2::geom_line(aes(y = tokyo)) +
    ggplot2::scale_x_continuous(breaks = breaks, labels = labels) +
    ggplot2::xlab("年") + ggplot2::ylab("東京")

gridExtra::grid.arrange(gg_all, gg_tokyo, nrow = 2, top = "指数化による移動平均")
```


#### 幾何平均
```{r, eval=FALSE}
#幾何平均
#0や負を含まない
#ベクトルの積積:cumprodコマンド
max(cumprod(x$All))^(1/length(x$All))

prod(x$All)^(1/length(x$All))

# 幾何平均は exp(mean(log(x)))
exp(mean(log(abs(x$All))))
```

### 時系列データの変動分解
Rで移動平均を求めるには`TTR`パッケージを導入するのが近道です。`TTR`パッケージは移動平均法（Simple Moving Average）や指数平滑法（Exponential Moving Average）といった関数を備えています。
[参考資料](http://tetsunosuke.hatenablog.com/entry/20111013/1318477738)

#### 移動平均 {.unnumbered}
移動平均は`TTR::SMA`関数で簡単に計算できます。`stats::filter`関数でも計算できるようです。
```{r}
breaks <- seq(1, length(x$Year), by = 12)
labels <- as.character(seq(2000, 2011, by = 1))

x %>% 
  dplyr::mutate(all_m12 = TTR::SMA(All, 12), tokyo_m12 = TTR::SMA(Tokyo, 12),
                year = row_number()) %>%
  ggplot2::ggplot(aes(x = year)) +
    ggplot2::geom_line(aes(y = all_m12)) +
    # ggplot2::geom_line(aes(y = All), colour = "red") +
    ggplot2::geom_line(aes(y = tokyo_m12), linetype = "dashed") +
    # ggplot2::geom_line(aes(y = Tokyo), colour = "blue") +
    ggplot2::scale_x_continuous(breaks = breaks, labels = labels) +
    ggplot2::xlab("") + ggplot2::ylab("平均現金給与額") +
    ggplot2::ggtitle("12か月移動平均")

Salary <- x
SalaryofTokyo.ts<-ts(Salary[,3]/10000, start = c(2000,1), frequency = 12)
plot(decompose(SalaryofTokyo.ts), xlab = "年月")
```


#### 指数平滑法
指数平滑法`TTR::EMA`関数で簡単に計算できます。
```{r}
breaks <- seq(1, length(x$Year), by = 12)
labels <- as.character(seq(2000, 2011, by = 1))

x %>% 
  dplyr::mutate(all_m12 = TTR::EMA(All, n = 12), tokyo_m12 = TTR::EMA(Tokyo, 12),
                year = row_number()) %>%
  ggplot2::ggplot(aes(x = year)) +
    ggplot2::geom_line(aes(y = all_m12)) +
    ggplot2::geom_line(aes(y = tokyo_m12), linetype = "dashed") +
    ggplot2::scale_x_continuous(breaks = breaks, labels = labels) +
    ggplot2::xlab("") + ggplot2::ylab("平均現金給与額") +
    ggplot2::ggtitle("指数平滑法")
```


### 自己相関
自己相関(Auto-Correlation)係数は`stats::acf`関数で計算できます。デフォルトではコレログラムを描画しますが、オブジェクトに代入するか`plot = FALSE`オプションを指定すれば自己相関係数を数値で表すことが可能です。
```{r}
result_acf_tokyo <- stats::acf(x$Tokyo,
                               main = "コレログラム：東京", xlab = "月差")
result_acf_tokyo
result_acf_all <- stats::acf(x$All,
                             main = "コレログラム：全国", xlab = "月差")
result_acf_all
```
　  

#### 偏自己相関
偏相関と同じように偏自己相関もあります。偏自己相関は時系列と以前のラグでは説明できない自分自身のラグの相関量です。`stats:acf`関数に`type = "partial"`オプションを指定するか`stats::pacf`関数を用います。
```{r}
result_pacf_tokyo <- stats::acf(x$Tokyo, type = "partial",
                                main = "コレログラム：東京", xlab = "月差")
result_pacf_tokyo

result_pacf_all <- stats::pacf(x$All,
                               main = "コレログラム：全国", xlab = "月差")
result_pacf_all
```
　  

### 指数の作成と利用
ここでは事例としてラスパイレス指数（Laspeyres index）が取り上げられていますが[R][R]には、このような指数を計算してくれるパッケージが既にいくつか用意されています。

* micEcon
* micEconIndex
* micEconAids

なお、これらのパッケージを用いて実際に計算をしてみたい場合は、[e-Stat](http://www.e-stat.go.jp)などからデータを引っ張ってきてみて計算して見てください。なお、[総務省のサイト](http://www.soumu.go.jp/)を検索すると分かりますがラスパイレス指数は主に公務員給与の適正性を示すために使われているようです。

---

<!-- Include Footer -->
```{r child="../../../common/footer.Rmd"}
```
