---
title: "第4章 例題・演習解答例"
output:
  html_document:
    css: style.css
    toc_depth: 2
---

<!-- Include shared Links -->
```{r example_4, child="../shared/links.Rmd"}
```

```{r setup, include=FALSE}
# 共通chunkオプションの指定
knitr::opts_chunk$set(warning = FALSE, echo = TRUE)

# データハンドリングで利用するパッケージの読み込み
require(tidyverse)

# 表示で利用する外部パッケージの読み込み
require(gridExtra)
require(DT)
require(knitr)
require(extrafont)

# モデリングで利用するパッケージの読み込み
require(psych)

# コンフリクトの解消
tidyverse::tidyverse_conflicts()

# 共通ローカル関数の読み込み
source("../shared/common.R")
```

本資料は『[ソフトウェアメトリクス統計分析入門 <i class="fa fa-external-link"></i>][BN2]』(以降、テキストと記載)の第4章の例題を[R <i class="fa fa-external-link"></i>][R]で解いた際の解答例を示したものです。また、[R Markdown <i class="fa fa-external-link"></i>][RM]を使うメリットを示すための一手段として作成していますので、テキストにおける計算方法とは異なる部分もあります。本資料で使用しているデータの入手に関してはテキストにてご確認下さい。  
本資料がHTML形式の場合、[R <i class="fa fa-external-link"></i>][R]のコードを参照するには右側にある**`[Code]`**ボタンをクリックして下さい。なお、JavaScriptは必ずOnにしてご覧下さい。  


# 例題 4.1
> 以下にプロジェクトごとに測定された「開発規模（KLOC）」、「レビュー工数」、「モジュールテスト工数」、「システムテストバグ件数」のデータがあります。
システムテスト開始時点で「システムテストバグ件数」を予測する式を作成したいと考えています。
> まずは、「システムテストバグ件数」を予測するのに「開発規模」、「レビュー工数」、「モジュールテスト工数」のいずれが最適かを調べてください。
> ※部分的に欠損値（未入力データ）があります。

## データの設定
本例題で利用するデータは予めCSVファイルとして保存されているものとします。
```{r, include=FALSE}
file <- "./data/ex_4.1.csv"
x <- read.csv(file, header = TRUE, sep = ",", fileEncoding = "CP932")
x
```

## データ分布の確認
散布図行列を用いてデータの分布を確認します。散布図行列は**`psych`**パッケージにある**`psych::pairs.panels`**関数を使うと相関係数まで同時に確認できるので便利です。なお、計算される相関係数はピアソンの積率相関係数です。
```{r}
x %>% 
  select(-Project) %>% 
  psych::pairs.panels(smooth = FALSE, scale = TRUE, lm = TRUE)
```

### 外れ値の除去
モジュール.テスト工数が1,000近いProject07のデータを外れ値と見なし分析対象から外すこととします。  
```{r}
x.rm <- x %>% 
  dplyr::filter(`モジュール.テスト工数` <= 950) # %>% 
  # tidyr::drop_na()

x.rm
```

## 再確認
外れ値（Project07）を除去した状態で再度散布図行列を描いてみます。  
```{r}
x.rm %>% 
  select(-Project) %>% 
  psych::pairs.panels(smooth = FALSE, scale = TRUE, lm = TRUE)
```

## 相関係数の確認
ここではRcmdrで使っている**`RcmdrMisc::rcorr.adjust`**関数を使っています。
```{r}
x %>% 
  dplyr::select(-Project) %>% 
  dplyr::rename(ST.bug = システムテスト.バグ件数,
                MT.time = モジュール.テスト工数,
                Review.time = レビュー.工数, KLOC = 開発規模) %>% 
  RcmdrMisc::rcorr.adjust(type = "pearson", use = "complete")
```
計算の結果、p値を見ると相関があると言えます。

## 偏相関の確認
次に擬似相関が含まれていないかを偏相関係数で確認してみます。ここでもRcmdrの`partial.cor {RcmdrMisc}`関数を使っています。
```{r}
x %>%   # 外れ値除去前後で確認しておく必要があるはず
  dplyr::select(-Project, -レビュー.工数) %>% 
  dplyr::rename(ST.bug = システムテスト.バグ件数,
                MT.time = モジュール.テスト工数, KLOC = 開発規模) %>% 
  RcmdrMisc::partial.cor(tests = TRUE, use = "complete")
```
計算の結果、開発規模(KLOC)とシステムバグ件数(ST.bug)の間には相関があると認められます。一方、モジュールテスト工数(MT.time)とシステムバグ件数(ST.bug)の間は修正p値から判断して相関があるとは認められない、すなわち擬似相関であると判断できます。

```{r}
x.cor <- cor.test(x$開発規模, x$システムテスト.バグ件数)$estimate %>% 
  round(2)

x %>% 
  dplyr::select(-Project, -レビュー.工数, -モジュール.テスト工数) %>% 
  dplyr::rename(ST.bug = システムテスト.バグ件数, KLOC = 開発規模) %>% 
  ggplot(aes(x = KLOC, y = ST.bug)) +
    geom_point() + 
    geom_smooth(method = "lm", se = TRUE) +
    xlab("開発規模[KLOC]") + ylab("システムテストバグ件数") +
    ggtitle(label = "外れ値除去前", subtitle = paste("　相関係数:", x.cor))

x.rm.cor <- cor.test(x.rm$開発規模, x.rm$システムテスト.バグ件数)$estimate %>% 
  round(2)

x.rm %>% 
  dplyr::select(-Project, -レビュー.工数, -モジュール.テスト工数) %>% 
  dplyr::rename(ST.bug = システムテスト.バグ件数, KLOC = 開発規模) %>% 
  ggplot(aes(x = KLOC, y = ST.bug)) +
    geom_point() + 
    geom_smooth(method = "lm", se = TRUE) +
    xlab("開発規模[KLOC]") + ylab("システムテストバグ件数") +
    ggtitle(label = "外れ値除去後", subtitle = paste("　相関係数:", x.rm.cor))
```


# 例題 4.2
> システムテスト開始時点の「開発規模」の測定値で、「システムテストバグ件数」を予測したいと考えています。
> 例題4.1と同じデータを使って、回帰分析を行い、予測式を作成してください。

## データの設定
本例題で利用するデータは例題4.1のデータをそのまま使い、必要な部分だけを取り出します。
```{r, include=FALSE}
file <- "./data/ex_4.1.csv"
x <- read.csv(file, header = TRUE, sep = ",", fileEncoding = "CP932") %>% 
  dplyr::select(-Project, -レビュー.工数, -モジュール.テスト工数) %>% 
  dplyr::rename(KLOC = 開発規模, ST.bug = システムテスト.バグ件数) 
df_print(x)
```

## 回帰分析
### 線形回帰モデルの算出
```{r}
result.lm <- x %>% 
  lm(ST.bug ~ KLOC, data = .)

summary(result.lm)
```

### 予測値のプロット
回帰分析の結果を確認してみます。
```{r}
x %>% 
  mutate(fit = fitted(result.lm)) %>% 
  ggplot(aes(x = ST.bug, y = fit)) +
    geom_point() +
    geom_text(aes(x = ST.bug + 0, y = fit + 1, label = row.names(x))) +
    coord_equal() +
    xlab("実測値") + ylab("予測値") +
    ggtitle("線形モデルの確認",
            subtitle = "ST.bug = 2.06 + 0.51*KLOC, R^2 = 0.847") +
    geom_abline(linetype = "dashed", colour = "red")
```


### 残差プロット
単回帰分析ではここまで確認する必要はないですが参考までに残差QQプロットを確認します。
```{r}
# plot(result.lm)

x %>%
  mutate(res = scale(residuals(result.lm))) %>%
  ggplot(aes(sample = res)) +
    geom_abline(col = "red", linetype = "dashed") +
    geom_qq() +
    coord_equal() +
    ggtitle("残差のQQプロット")
```

# 演習 4.1
> 以下に4 つのx, yの2変数のデータセット例があります。それぞれのデータセットごとに相関係数の算出と散布図の作成を行って違いを考察してください。

## データの設定
本演習で利用するデータは予めCSVファイルとして保存されているものとします。
```{r, include=FALSE}
file <- "./data/ex4_1.csv"
x <- read.csv(file, header = TRUE, row.names = 1, sep = ",",
              fileEncoding = "CP932")

df_print(x)
```

## 可視化
各データ毎に散布図を描き、計算した相関係数、p値、95%信頼区間の値を添えます。比較のために各グラフの縦横軸は同範囲としています。
```{r}
cor.1 <- cor.test(x$x.1, x$y.1)
cor.2 <- cor.test(x$x.2, x$y.2)
cor.3 <- cor.test(x$x.3, x$y.3)
cor.4 <- cor.test(x$x.4, x$y.4)

xlim <- c(0, 20)
ylim <- c(0, 15)

g.1 <- x %>% 
  select(x = x.1, y = y.1) %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_point() +
  ggtitle("データ例1",
          subtitle = paste(" R = ", round(cor.1$estimate, 2),
                           ", p = ", round(cor.1$p.value, 3),
                           ", conf =[", round(cor.1$conf.int[1], 2),
                           ", ", round(cor.1$conf.int[2], 2),
                           "]", sep = "")) +
  coord_cartesian(xlim, ylim) +
  geom_smooth(method = "lm", se = FALSE)

g.2 <- x %>% 
  select(x = x.2, y = y.2) %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_point() +
  ggtitle("データ例2",
          subtitle = paste(" R = ", round(cor.2$estimate, 2),
                           ", p = ", round(cor.2$p.value, 3),
                           ", conf =[", round(cor.2$conf.int[1], 2),
                           ", ", round(cor.2$conf.int[2], 2),
                           "]", sep = "")) +
  coord_cartesian(xlim, ylim) +
  geom_smooth(method = "lm", se = FALSE)


g.3 <- x %>% 
  select(x = x.3, y = y.3) %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_point() +
  ggtitle("データ例3",
          subtitle = paste(" R = ", round(cor.3$estimate, 2),
                           ", p = ", round(cor.3$p.value, 3),
                           ", conf =[", round(cor.3$conf.int[1], 2),
                           ", ", round(cor.3$conf.int[2], 2),
                           "]", sep = "")) +
  coord_cartesian(xlim, ylim) +
  geom_smooth(method = "lm", se = FALSE)


g.4 <- x %>% 
  select(x = x.4, y = y.4) %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_point() +
  ggtitle("データ例4",
          subtitle = paste(" R = ", round(cor.4$estimate, 2),
                           ", p = ", round(cor.4$p.value, 3),
                           ", conf =[", round(cor.4$conf.int[1], 2),
                           ", ", round(cor.4$conf.int[2], 2),
                           "]", sep = "")) +
  coord_cartesian(xlim, ylim) +
  geom_smooth(method = "lm", se = FALSE)


gridExtra::grid.arrange(g.1, g.2, g.3, g.4, nrow = 2, ncol = 2)
```

### Rcmdrの場合
Rcmdrでは順に処理して下さい。なお、相関係数については［統計量］-［要約］-［相関の検定...］を使うと相関係数の検定(無相関の検定)まで行えるので便利です。

![相関の検定](./fig/Rcmdr_cor_test.jpg)

![相関の検定ダイアログ](./fig/Rcmdr_cor_test_dialog.jpg)

## 考察
まず、全てのデータに対して相関係数、p値、信頼区間の全てが同一になるデータになっている点は非常に驚きです。

さて、データ例1は相関係数で判断し直線回帰を行うには向いているデータ分布だと考えます、残る3つについては、それぞれ、以下の理由においてデータ例1と同列に扱うのは好ましくないと考えます。

データ例2は明らかに直線関係はなく曲線的な関係であることから相関係数や直線回帰で扱うには不適切です。
データ例3は大きく外れた値が相関係数に影響を与えていることが想定されるので、データ例1と同様に扱う場合は外れ値を外す必要があります。
データ例4は大きく外れた値が相関関係があるように見せかけているのは一目瞭然です。

したがって、相関係数や直線回帰で扱うのに適切なのはデータ例1、ならびに外れ値を外したデータ例2ということになります。ただし、データ例2は本当に外れ値を外すべきかどうかはデータを調べて本当に外れ値なのかどうかを判断してからの方がベターだと考えます。


# 演習 4.2
> 第4章の補足4.1を参考にして偏相関係数を算出します。開発規模、モジュールテスト工数、システムテストバグ件数のデータを用いて開発規模を制御変数としたモジュールテスト工数とシステムテストバグ件数の偏相関係数を算出してください。
> ただし、Rコマンダーは使用せず以下の手順で行ってください。  
    手順1.開発規模とモジュールテスト工数の単回帰分析の回帰パラメータを算出  
    手順2.同様に開発規模とシステムテストバグ件数の単回帰分析の回帰パラメータを算出  
    手順3.算出したパラメータ値を使ってモジュールテスト工数とシステムテストバグ件数の予測値を入力  
    手順4.「実測値－予測値」でモジュールテスト工数とシステムテストバグ件数の残差を入力  
    手順5.モジュールテスト工数残差とシステムテストバグ件数残差の相関係数を算出  
> これが、開発規模を制御変数としたモジュールテスト工数とシステムテストバグ件数の偏相関係数となります。

## データの設定
本演習で利用するデータは予めCSVファイルとして保存されているものとします。
```{r, include=FALSE}
# 演習のデータを変形せずに読み込み、分析用データフレームに変換する
file <- "./data/ex4_2.csv"
x <- read.csv(file, header = TRUE, sep = ",", fileEncoding = "CP932")

  
df_print(x)  
```

## 手順1
開発規模を説明変数とモジュールテスト工数を目的変数として単回帰分析の回帰パラメータを算出します。
```{r}
model.lm.mt.hour.kloc <- x %>% 
  lm(mt.hour ~ kloc, data = .)

summary(model.lm.mt.hour.kloc)
```

## 手順2
同様に開発規模を説明変数とシステムテストバグ件数を目的変数として単回帰分析の回帰パラメータを算出します。
```{r}
model.lm.st.bugs.kloc <- x %>% 
  lm(st.bugs ~ kloc, data = .)

summary(model.lm.st.bugs.kloc)
```

## 手順3
算出したパラメータ値を使ってモジュールテスト工数とシステムテストバグ件数の予測値を算出します。なお、欠損値があるため別々に計算してマージします。
```{r}
x.fitted.mt.hour <- x %>% 
  tidyr::drop_na(mt.hour) %>% 
  mutate(fitted.mt.hour = fitted(model.lm.mt.hour.kloc)) %>% 
  select(project, fitted.mt.hour)

df_print(x.fitted.mt.hour)

x.fitted.st.bugs <- x %>% 
  tidyr::drop_na(st.bugs) %>% 
  mutate(fitted.st.bugs = fitted(model.lm.st.bugs.kloc)) %>% 
  select(project, fitted.st.bugs)

df_print(x.fitted.st.bugs)

x.fitted <- x %>% 
  dplyr::full_join(x.fitted.mt.hour, by = "project") %>% 
  dplyr::full_join(x.fitted.st.bugs, by = "project")

df_print(x.fitted)
```

## 手順4
「実測値－予測値」でモジュールテスト工数とシステムテストバグ件数の残差を計算します。
```{r}
x.residula <- x.fitted %>% 
  mutate(residual.mt.hour = (mt.hour - fitted.mt.hour), 
         residual.st.bugs = (st.bugs - fitted.st.bugs))

df_print(x.residula)
```

## 手順5
モジュールテスト工数残差とシステムテストバグ件数残差の相関係数を算出します。
```{r}
cor.test(x.residula$residual.mt.hour, x.residula$residual.st.bugs)
```

## 比較
比較のためにRで直接、偏相関係数を算出します。
```{r}
x %>% 
  dplyr::select(-project) %>% 
  RcmdrMisc::partial.cor(tests = TRUE, use = "complete")
```


# 演習 4.3
> 以下にプロジェクトごとの開発規模（KLOC）、総工数（人月）、製品カテゴリのデータがあり開発規模から総工数を予測する回帰式をつくろうとしています。
> 製品カテゴリの層別に散布図を作成して必要ならば製品カテゴリ別に回帰式を作成してください。

## データの設定
本演習で利用するデータは予めCSVファイルとして保存されているものとします。
```{r, include=FALSE}
# 演習のデータを変形せずに読み込み、分析用データフレームに変換する
file <- "./data/ex4_3.csv"
x <- read.csv(file, header = TRUE, sep = ",", fileEncoding = "CP932")

df_print(x)
```

## 散布図の描画
開発規模と総工数の関係を散布図で描きます。散布図は製品カテゴリによる層別なし／ありの両方で描きます。
```{r}
gg.non <- x %>% 
  ggplot(aes(x = kloc, y = man.hour)) +
    geom_point() +
    geom_text(aes(x = kloc, y = man.hour + 1, label = row.names(.))) +
    geom_smooth(method = "lm", se = TRUE) +
    ggtitle("層別なし") +
    xlab("開発規模[KLOC]") + ylab("総工数[H]")
 
gg.yes <- x %>% 
  ggplot(aes(x = kloc, y = man.hour, colour = category)) + 
    geom_point() +
    geom_text(aes(x = kloc, y = man.hour + 1, label = row.names(.))) +
    geom_smooth(method = "lm", se = TRUE) +
    ggtitle("層別あり") +
    xlab("開発規模[KLOC]") + ylab("総工数[H]") +
    theme(legend.position = "none")

gridExtra::grid.arrange(gg.non, gg.yes, nrow = 1, ncol = 2,
                        top = grid::textGrob("開発規模と総工数の関係"))


```

## 回帰モデルの作成
### 層別なしの場合
```{r}
model.lm.non <- x %>% 
  lm(man.hour ~ kloc, data = .)

summary(model.lm.non)
```

### 層別ありの場合
```{r}
model.lm.a <- x %>% 
  filter(category == "A") %>% 
  lm(man.hour ~ kloc, data = .)

summary(model.lm.a)

model.lm.b <- x %>% 
  filter(category == "B") %>% 
  lm(man.hour ~ kloc, data = .)

summary(model.lm.b)
```

## 結論
各モデルのp値(t検定、F検定共)を見る限りモデルとしては使えそうなモデルである。また、各モデルの寄与率は以下の通りであり、層別なしの場合でも約5割のラインを超えている。  
この結果からどのモデルを採用しても予測できると判断できるが、層別なしの場合より層別ありの方が寄与率が高いので、今回は層別ありのモデルを採用することとする。

層別なしの場合
$$R^2 = `r round(summary(model.lm.non)$r.squared, 2)`$$  
層別ありの場合
$$R_a^2 = `r round(summary(model.lm.a)$r.squared, 2)` ／ R_b^2 = `r round(summary(model.lm.b)$r.squared, 2)`$$  

### モデルの評価
単回帰なので、ここまで見る必要はないが、基本的診断プロットを行ってみます。基本的診断プロットを見ると寄与率は低いものの層別なしの場合の方が良さそうに見えます。
```{r}
oldpar <- par()
par(mfrow = c(2, 2))
plot(model.lm.non)
plot(model.lm.a)
plot(model.lm.b)
par(oldpar)
```


# 演習 4.4
> 以下にモジュールごとの規模（KLOC）、レビュー実施時間（人時）、モジュールテストバグ件数のデータがあります。
> 目的変数をモジュールテストバグ件数、説明変数を規模とレビュー実施時間の2つとした重回帰分析を行ってください。
> 重回帰分析は本文中では扱っていませんが、操作方法は単回帰分析とほぼ同様です。説明変数選択の際にCtrlキーを押しながら複数選択して実行するだけです。チャレンジしてみてください。


## データの設定
本演習で利用するデータは予めCSVファイルとして保存されているものとします。
```{r, include=FALSE}
# 演習のデータを変形せずに読み込み、分析用データフレームに変換する
file <- "./data/ex4_4.csv"
x <- read.csv(file, header = TRUE, sep = ",", fileEncoding = "CP932")

x %>% 
  select(module, '規模' = kloc, 'レビュー実施時間' = m.hour,
         'MTバグ件数' = bugs) %>% 
  df_print()
```

### データの確認
```{r}
x %>% 
  select(-module) %>% 
  psych::pairs.panels(smooth = FALSE, scale = TRUE, lm = TRUE)
```


## 重回帰分析
```{r}
result.lm <- x %>% 
  lm(bugs ~ kloc + m.hour, data = .)

summary(result.lm)
```

重回帰分析(直線回帰)の結果、開発規模(kloc)とレビュー工数(m.hour)でモジュールテストにおけるバグの摘出数の約9割を説明できることが分かります。また、F検定のp値を見ても妥当なことが分かります。

## モデルの確認
念のために実測値と予測値の比較を行ってみます。予測値は`fitted {stats}`関数、または、`predict {stats}`関数で計算できます。Rcmdrの予測値の計算では`fitted {stats}`が使われています。
```{r}
x %>% 
  mutate(fit = fitted(result.lm)) %>% 
  select(bugs, fit, module) %>% 
  ggplot(aes(x = bugs, y = fit)) +
    geom_point() +
    geom_text(aes(x = bugs + 4, y = fit + 2, label = module)) +
    coord_equal() +
    xlab("実測値(モジュールテストバグ件数)") + ylab("予測値") +
    ggtitle("線形モデルの確認",
            subtitle = "bugs = 27.9 + 1.28*kloc - 1.74*m.hour") +
    geom_abline(linetype = "dashed", colour = "red")
```

### Rcmdrの場合
Rcmdrを使う場合は［モデル］-［計算結果をデータとして保存...］を実行し表示されたダイアログから"予測値"のみをチェックして［OK］ボタンをクリックします。  

![計算結果をデータとして保存](./fig/Rcmdr_fitted_menu.jpg)

![保存するデータの選択](./fig/Rcmdr_fitted_select.jpg)

(アクティブ)データセットに選択したデータ(fitted.RegModel.1)が追加されます。

![追加されたデータ(fitted.RegModel.1)](./fig/Rcmdr_fitted_dataset.jpg)

その後、［グラフ］-［散布図...］を実行しx変数(説明変数)にモジュールテストバグ件数、y変数(目的変数)にモジュールテストバグ件数の予測値(fitted.RegModel.1)を選択して散布図を描きます。

![実測値と予測値の散布図](./fig/Rcmdr_fitted_plot.jpg)

Rcmdrのメニューからは$y = x$の直線(赤点線)は引けませんので、Rスクリプト画面から`abline(0, 1, col = "red", lty = "dashed")`を実行して下さい。

![$y = x$の直線を引くための関数abline](./fig/Rcmdr_fitted_plot_abline.jpg)

![実測値と予測値の散布図($y = x$の直線付き)](./fig/Rcmdr_fitted_plot_abline_graph.jpg)


---

<!-- Include Footer -->
```{r child="../shared/footer.Rmd"}
```
