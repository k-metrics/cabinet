---
title: "ggplot2のすゝめ"
output:
  learnr::tutorial:
    highlight: textmate
    md_extensions: -ascii_identifiers
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
# 共通chunkオプションの指定
knitr::opts_chunk$set(warning = FALSE, echo = TRUE)

require(learnr)
require(tidyverse)
require(gridExtra)
require(DT)
require(knitr)
tidyverse::tidyverse_conflicts()
```

<!-- 最初に変数fileに使用するデータをフルパスで指定して下さい -->
```{r common, include=FALSE}
if (Sys.getenv("OS") == "Windows_NT") {
  file_path <- "C:\\Users\\suzuki\\Dropbox\\RStudio\\cabinet\\program\\basics\\data\\odc.csv"
} else {
  file_path <- "/home/sampo/Dropbox/RStudio/cabinet/program/basics/data/odc.csv"
}
odc <- read_csv(file_path, locale = locale(encoding = "CP932"), progress = FALSE)
```

## About Tutorial
「dplyrのすゝめ」ではデータの扱い方を学びましたが、本チュートリアルではODC分析における可視化を例にして[R][R]で可視化処理するために必要な基礎知識を学びます。なお、本チュートリアルを実行するための必要な環境については[こちら](https://k-metrics.github.io/cabinet/program/basics/#チュートリアル資料について)で確認して下さい。

### 対象データ
ODC
前述のように具体的な事例としてBTSのデータを用います。BTSのデータは[Redmine.JP](http://redmine.jp/glossary/i/issue/)で公開されている[サンプルDB](http://www.redmine.org/projects/redmine/issues)を用いますので、予めCSV形式でエクスポートしておいて下さい。


#### 事前設定
データファイルのフルパスを本ファイルの`common`チャンクにある`file_path`に設定しておいて下さい。

### 整然データ
整然データ（Tidy Data）とはJournal of Statistical Software Vol.59(2014)に掲載されたHadley Wickhamの論文[Tidy Data](https://www.jstatsoft.org/article/view/v059i10)において提唱されたデータ分析に有用な概念です。簡潔に日本語で整理された情報は[整然データとは何か](http://id.fnshr.info/2017/01/09/tidy-data-intro/)や[整然データってなに？](https://speakerdeck.com/fnshr/zheng-ran-detatutenani)で公開されていますので、まずは、こちらで整然データ（Tidy Data）の概念を把握しておいて下さい。

## Tidy

### データの確認
```{r, eval=FALSE}
odc %>% 
  DT::datatable()
```

```{r, eval=FALSE}
odc %>% 
  dplyr::select(Status = 'ステータス', Result = '解決状況', Date = '発生日',
                Rank = '障害ランク', Step = '欠陥検出工程',
                Trigger = '発生トリガー', Type = '欠陥実装タイプ') %>% 
  dplyr::count(Date, Trigger) %>% 
  ggplot2::ggplot(aes(x = Date, y = n)) + 
    ggplot2::geom_bar(aes(fill = Trigger), stat = "identity")
```

```{r, eval=FALSE}
odc %>% 
  dplyr::select(Status = 'ステータス', Result = '解決状況', Date = '発生日',
                Rank = '障害ランク', Step = '欠陥検出工程',
                Trigger = '発生トリガー', Type = '欠陥実装タイプ') %>% 
  dplyr::count(Date, Trigger) %>% 
  tidyr::spread(key = Trigger, value = n) %>% 
  dplyr::mutate_if(is.numeric, funs(replace(., is.na(.), 0))) %>% 
  dplyr::mutate_if(is.numeric, cumsum) %>%
  tidyr::gather(key = Trigger, value = n, -Date) %>% 
  ggplot2::ggplot(aes(x = Date, y = n)) + 
    ggplot2::geom_bar(aes(fill = Trigger), stat = "identity")
```

```{r, eval=FALSE}
odc %>% 
  dplyr::select(Status = 'ステータス', Result = '解決状況', Date = '発生日',
                Rank = '障害ランク', Step = '欠陥検出工程',
                Trigger = '発生トリガー', Type = '欠陥実装タイプ') %>% 
  dplyr::filter(Type != "（障害ではない）") %>% 
  dplyr::count(Date, Trigger) %>% 
  tidyr::spread(key = Trigger, value = n) %>% 
  dplyr::mutate_if(is.numeric, funs(replace(., is.na(.), 0))) %>% 
  dplyr::mutate_if(is.numeric, cumsum) %>%
  tidyr::gather(key = Trigger, value = n, -Date) %>% 
  ggplot2::ggplot(aes(x = Date, y = n)) + 
    ggplot2::geom_bar(aes(fill = Trigger), stat = "identity")
```

```{r, eval=FALSE}
odc %>% 
  dplyr::select(Status = 'ステータス', Result = '解決状況', Date = '発生日',
                Rank = '障害ランク', Step = '欠陥検出工程',
                Trigger = '発生トリガー', Type = '欠陥実装タイプ') %>% 
  dplyr::filter(Type != "（障害ではない）") %>% 
  dplyr::count(Date, Rank) %>% 
  tidyr::spread(key = Rank, value = n) %>% 
  dplyr::mutate_if(is.numeric, funs(replace(., is.na(.), 0))) %>% 
  dplyr::mutate_if(is.numeric, cumsum) %>%
  tidyr::gather(key = Rank, value = n, -Date) %>% 
  ggplot2::ggplot(aes(x = Date, y = n)) + 
    ggplot2::geom_bar(aes(fill = Rank), stat = "identity")
```

```{r, eval=FALSE}
odc %>% 
  dplyr::select(Status = 'ステータス', Result = '解決状況', Date = '発生日',
                Rank = '障害ランク', Step = '欠陥検出工程',
                Trigger = '発生トリガー', Type = '欠陥実装タイプ') %>% 
  dplyr::filter(Type != "（障害ではない）") %>% 
  dplyr::count(Date, Step) %>% 
  tidyr::spread(key = Step, value = n) %>% 
  dplyr::mutate_if(is.numeric, funs(replace(., is.na(.), 0))) %>% 
  dplyr::mutate_if(is.numeric, cumsum) %>%
  tidyr::gather(key = Step, value = n, -Date) %>% 
  ggplot2::ggplot(aes(x = Date, y = n)) + 
    ggplot2::geom_bar(aes(fill = Step), stat = "identity")
```


```{r, eval=FALSE}
odc %>% 
  dplyr::select(Status = 'ステータス', Result = '解決状況', Date = '発生日',
                Rank = '障害ランク', Step = '欠陥検出工程',
                Trigger = '発生トリガー', Type = '欠陥実装タイプ') %>% 
  dplyr::filter(Type != "（障害ではない）") %>% 
  dplyr::count(Date, Type) %>% 
  tidyr::spread(key = Type, value = n) %>% 
  dplyr::mutate_if(is.numeric, funs(replace(., is.na(.), 0))) %>% 
  dplyr::mutate_if(is.numeric, cumsum) %>%
  tidyr::gather(key = Type, value = n, -Date) %>% 
  ggplot2::ggplot(aes(x = Date, y = n)) + 
    ggplot2::geom_bar(aes(fill = Type), stat = "identity")
```

この様にパイプ演算子は中間変数を作成することなく処理の手順を記述できます。コードの可読性が上がるというメリットもあります。パイプ演算子を使わない以下の場合と比較して見て下さい。


## Import/Overview
まず、BTSデータをインポートします。インポート方法には複数の方法が考えられますが、本チュートリアルでは環境構築の手間を考慮してファイルからインポートする方法を用います。実際の環境においてはSQLによるアクセスが使える場合には、分析自動化の観点からもSQLによるインポートを実装しておくことをおすゝめします。

### ファイルからインポートする
ファイルからデータをインポートする場合、ファイル形式としてはテキスト形式であるCSV形式が最も汎用的です。RでCSVファイルをインポートするには基本パッケージで提供されている`util::read.csv`関数を用いるのが一般的に紹介されている方法です。ただ、BTSのデータの様に様々な形式のデータが混在しているファイルを読み込むには`readr::read_csv`関数の方が適しています。

`readr::read_csv`関数の引数は以下のようになっています。詳細はヘルプで確認して下さい。
```{r, eval=FALSE}
read_csv(file, col_names = TRUE, col_types = NULL,
  locale = default_locale(), na = c("", "NA"), quoted_na = TRUE,
  quote = "\"", comment = "", trim_ws = TRUE, skip = 0, n_max = Inf,
  guess_max = min(1000, n_max), progress = show_progress())
```

注意すべきは以下のような点です。

* ファイル先頭行に列名（ヘッダ）が含まれているか否か（col_names）
* 欠損値の扱い方（na）
* ファイルのエンコーディング（locale）

特に複数のプラットフォームが混在している場合は、ファイルのエンコーディングに注意して下さい。読み込んだファイルが文字化けする場合は以下のようにエンコーディングを明示的に指定して下さい。

```{r, eval=FALSE}
locale = locale(encoding = "CP932")     # シフトJISコードの場合
```

## Import/Read CSV
では、実際にファイルを読み込むコードを書いて実行して見ましょう。分からない場合は前トピックで確認するか`Hint`ボタンをクリックして見て下さい。




### ファイルの読み込み
ファイル名は既に変数`file_path`に格納してあるものとし、前述の`readr::read_csv関数を用いて読み込みます。
```{r import, exercise=TRUE, exercise.setup="common", message=FALSE}
bugs <- file_path %>% 
  
```

```{r import-hint}
bugs <- file_path %>% 
  readr::read_csv(locale = locale(encoding = "CP932"))
```

### 読み込んだ結果の確認
次に読み込んだデータを確認して見ましょう。
```{r print, exercise=TRUE, exercise.setup="common", message=FALSE}
bugs
```

```{r print-hint}
bugs
```

## Tidy/Overview
次に読み込んだデータを扱いやすいように整形します。BTSは通常、項目がカスタマイズされていて様々なデータが登録されていますが、ここでは以下の項目を対象としますので必要な項目のみを抽出（選択）します。

項目名     | 内容                          | field      | table
-----------|-------------------------------|------------|--------
\#         | チケットID（ユニーク）        | id         | issues
トラッカー | チケットの大分類              | tracker_id | issues 
ステータス | チケットの進捗状況            | status_id  | issues
作成日     | チケットの作成日（POSIX形式） | created_on | issues

また、日本語の項目名はなにかと扱いが面倒になることがありますので、英語の項目名に変更し、必要に応じて項目の内容を加工します。

## Tidy/Select
前トピックで確認したように読み込んだRedmineデータには全ての項目（変数、列）が含まれているので、必要な項目（列）のみを抜き出します。R Commanderの時は事前にCSVファイルを加工するか`base::subset`関数を用いていましたが、ここでは`dplyr::select`関数を使います。`dplyr::select`関数は、対象となるデータフレームに続いて抜き出したい項目（変数、列）を指定します。
```{r, eval=FALSE}
select(data_frame, col_name, ...)
```

### Select
では、実際に`#`、`トラッカー`、`ステータス`、`作成日`の四項目（変数、列）を抽出（選択）して見ましょう。
```{r select, exercise=TRUE, exercise.setup="common", message=FALSE}
bugs %>% 
  
```

```{r select-hint}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日')
```

## Tidy/Rename
項目名（変数名、列名）を以下のような扱いやすい英語に変更しておきます。

項目名     | 変更後の項目名（英語）
-----------|-----------------------------------
\#         | ID
トラッカー | Tracker
ステータス | Status
作成日     | DateTime（POSIXct形式）

項目名（変数名、列名）を変更するには`dplyr::rename`関数を使います。
```{r, eval=FALSE}
rename(data_frame, new_name = old_name, ...)
```

### Rename
では、実際に各項目名（変数名、列名）を変更してみましょう。
```{r rename, exercise=TRUE, exercise.setup="common", message=FALSE}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 

```

```{r rename-hint}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日')
```

## Tidy/Mutate
これで処理に必要な項目の選択ができましたが、作成日が年月日時分秒形式（POSIXct形式）になっていますのでこれを年月日形式の項目（列）`Date`として追加します。新しい項目を作成するにはWindow関数である`dplyr::mutate`関数を使います。
```{r, eval=FALSE}
mutate(data_frame, new_col = func(old_col), ...)
```

日時データを日付データに変換するには`lubridate`パッケージの`lubridate::as_data`関数を用いるのが便利です。タイムゾーンの指定も可能です。詳しくはヘルプで確認して下さい。
```{r, eval=FALSE}
as_date(vec_data, ...)
```

### Mutate
作成日（日時データ、DateTime）から作成日（日付データ、Date）を作成してみましょう。
```{r mutate, exercise=TRUE, exercise.setup="common", exercise.lines=5,	message=FALSE}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 

```

```{r mutate-hint}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime))
```

## Transform/Group By
次に取り込んだデータをクロス集計します。[R][R]ではクロス集計に`base::table`関数を使うことが多いですが、ここではモダンなコーディング処理で集計を行ってみます。クロス集計の前に単純集計を行ってみましょう。データフレーム内のデータ個数を数えるには`dplyr::group_by`関数を用いて集計したい項目（変数、列）を指定して`dplyr::tally`関数でデータの個数をカウントします。
```{r, eval=FALSE}
dplyr::group_by(data_frame, group, ...) %>% 
  dplyr::tally()
```

### Group By
まずは日付日付(`Date`)毎の単純集計を行ってみましょう。
```{r date, exercise=TRUE, exercise.setup="common", exercise.lines=7}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 

```

```{r date-hint}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date) %>% 
  dplyr::tally()
```

同様にステータスでも集計してみましょう。
```{r status, exercise=TRUE, exercise.setup="common", exercise.lines=7}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
```

```{r status-hint}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Status) %>% 
  dplyr::tally()
```

### Count
`dplyr::count`関数は`dplyr::group_by %>% dplyr::tally %>% dplyr::ungroup`処理を一括で行うものです。先程の処理を`dplyr::count`関数を用いて記述してみましょう。
```{r count, exercise=TRUE, exercise.setup="common", exercise.lines=6}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 

```

```{r count-hint}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::count(Date)
```

## Transform/Cross Tabulation
次に日付(`Date`)とステータス(`Status`)でクロス集計を行ってみましょう。クロス集計でも単純集計で利用した`dplyr::group_by`関数か`dplyr::count`関数を用います。
```{r, eval=FALSE}
dplyr::group_by(data_frame, group1, group2, ...) %>% 
  dplyr::tally()

dplyr::count(data_frame, group1, group2, ...)
```

### Group By/Count
では実際にクロス集計してみましょう。
```{r cross, exercise=TRUE, exercise.setup="common", exercise.lines=7}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 

```

```{r cross-hint}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date, Status) %>% 
  dplyr::tally()

bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::count(Date, Status)
```

## Tidy/Spread
集計結果を見やすいようなクロス集計表に変形してみましょう。変形には`tidyr::spread`関数を用います。横軸（列方向）に展開したい項目（変数、列）を`key`に集計したい数値を`value`に設定します。詳細はヘルプで確認して下さい。
```{r, eval=FALSE}
spread(data_frame, key, value, fill = NA, convert = FALSE, drop = TRUE,
       sep = NULL)
```

### Spread
縦軸（行）方向を日付（`Date`）に横軸（列）方向をステータス（`Status`）としてクロス集計表にしてみましょう。
```{r spread, exercise=TRUE, exercise.setup="common", exercise.lines=8, message=FALSE}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date, Status) %>% 
  dplyr::tally() %>% 
  
```

```{r spread-hint}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date, Status) %>% 
  dplyr::tally() %>% 
  tidyr::spread(key = Status, value = n)
```

## Transform/Cusum
クロス集計表ができましたので次に累積度数を求めてみます。累積度数を計算するには`base::cumsum`関数を用います。
```{r, eval=FALSE}
cumsum(vec_data)
```

### Cumsum
日付（`Date`）を計算した時と同じように日付毎のチケットデータ数の累積度数（`Cumsum`）を計算してみましょう。
```{r cusum, exercise=TRUE, exercise.setup="common", exercise.lines=10, message=FALSE}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date) %>% 
  dplyr::tally() %>% 
```

```{r cusum-hint}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date) %>% 
  dplyr::tally() %>% 
  dplyr::ungroup() %>%            # ungroupはなくても集計できます
  dplyr::mutate(Cum = cumsum(n))
```

## Visualize
度数集計したデータを可視化してみましょう。可視化にはパイプ演算子をそのまま使える`ggplot2`パッケージを用います。`ggplot2`パッケージの基本文法は以下のような形ですが、詳細は別チュートリアルにて
```{r, eval=FALSE}
ggplot(aes(x, y, ...)) +
  geom_*(aes(x, y, ...), ...)
```

### 棒グラフ
まず、日毎のチケット起票数を棒グラフで描いてみましょう。棒グラフを描くには`ggplot2::geom_bar`関数を用います。
```{r geom_bar, exercise=TRUE, exercise.setup="common", exercise.lines=11, message=FALSE}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::count(Date) %>% 
  dplyr::mutate(Cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = Date)) + 
    ggplot2::geom_bar(aes(y = n), stat = "identity") + 
    ggplot2::ylab("Num of Tickets")
```

### 折れ線グラフ
続いてチケット累計度数を折れ線グラフで描いて見ましょう。折れ線グラフを描くには`ggplot::geom_line`関数を用います。
```{r geom_line, exercise=TRUE, exercise.setup="common", exercise.lines=11, message=FALSE}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::count(Date) %>% 
  dplyr::mutate(Cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = Date)) + 
    ggplot2::geom_line(aes(y = Cum)) + 
    ggplot2::ylab("Num of Tickets")
```

### 重ね合わせ
前述の棒グラフと折れ線グラフを重ねてみましょう。`ggplot2`パッケージでは基本的に重ねて描きたいグラフは追記していくだけで描くことができます。
```{r ggplot, exercise=TRUE, exercise.setup="common", exercise.lines=12, message=FALSE}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::count(Date) %>% 
  dplyr::mutate(Cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = Date)) + 
    ggplot2::geom_bar(aes(y = n), stat = "identity", na.rm = TRUE) + 
    ggplot2::geom_line(aes(y = Cum), na.rm = TRUE) + 
    ggplot2::ylab("Num of Tickets")
```

```{r, eval=FALSE, include=FALSE}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date) %>% 
  dplyr::tally() %>% 
  dplyr::ungroup() %>%            # ungroupはなくても集計できます
  dplyr::mutate(Cum = cumsum(n)) %>% 
  tibble::rowid_to_column() %>% 
    ggplot2::ggplot(ggplot2::aes(x = rowid)) + 
    ggplot2::geom_bar(aes(y = n), stat = "identity", na.rm = TRUE) + 
    ggplot2::geom_line(aes(y = Cum), na.rm = TRUE) + 
    ggplot2::ylab("Num of Tickets")
```



## Transform/Join
グラフを描く際に作成した日毎の度数集計をクロス集計表と結合させて見ましょう。データフレームの結合には`dplyr::inner_join`関数を使います。`dplyr::inner_join`関数は二つのデータフレームの双方にあるデータをキーに結合を行います。
```{r, eval=FALSE}

```

### Join
```{r inner_join, exercise=TRUE, exercise.setup="common", exercise.lines=18, message=FALSE}
sum_tbl <- bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::count(Date) %>% 
  dplyr::mutate(Cum = cumsum(n)) %>% 
  dplyr::rename(Sum = n)

bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::count(Date, Status) %>% 
  tidyr::spread(key = Status, value = n) %>% 
  dplyr::inner_join(sum_tbl)
```

## Tidy/Gather
```{r, eval=FALSE}
tidyr::gather()
```

### 重ね合わせグラフ
```{r, eval=FALSE}
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::count(Date, Status) %>% 
  ggplot2::ggplot(aes(x = Date)) +
    ggplot2::geom_bar(aes(y = n, fill = Status), stat = "identity")

bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::count(Date) %>% 
  dplyr::mutate(Cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = Date)) + 
    ggplot2::geom_line(aes(y = Cum)) + 
    ggplot2::geom_bar(aes(y = n), stat = "identity")

bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  ggplot2::ggplot(aes(x = Date, fill = Status)) + 
    ggplot2::geom_bar()

```

### Gather
```{r, eval=FALSE, include=FALSE}
# ステータス別累計グラフ
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date, Status) %>% 
  dplyr::tally() %>% 
  tidyr::spread(key = Status, value = n) %>% 
  dplyr::ungroup() %>%
  dplyr::mutate_at(vars(-Date), funs(replace(., is.na(.), 0))) %>% 
  dplyr::mutate_if(is.numeric, cumsum) %>%
  # dplyr::mutate_at(vars(-Date), funs(cumsum)) %>%
  tidyr::gather(key = Status, value = Count, -Date) %>%
  ggplot2::ggplot(aes(Date)) +
  # tibble::rowid_to_column() %>%
  # tidyr::gather(key = Status, value = Count, -Date, -rowid) %>%
  # ggplot2::ggplot(aes(rowid)) +
    ggplot2::geom_bar(aes(y = Count, fill = Status), stat = "identity") +
    ggplot2::geom_line(aes(y = Count, colour = Status), position = "stack") 

# 
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date, Status) %>% 
  dplyr::tally() %>% 
  tidyr::spread(key = Status, value = n) %>% 
  dplyr::ungroup() %>%
  dplyr::mutate_at(vars(-Date), funs(replace(., is.na(.), 0))) %>% 
  # dplyr::mutate_if(is.numeric, cumsum) %>%
  # dplyr::mutate_at(vars(-Date), funs(cumsum)) %>%
  tidyr::gather(key = Status, value = Count, -Date) %>%
  ggplot2::ggplot(aes(Date)) +
  # tibble::rowid_to_column() %>%
  # tidyr::gather(key = Status, value = Count, -Date, -rowid) %>%
  # ggplot2::ggplot(aes(rowid)) +
    ggplot2::geom_bar(aes(y = Count), stat = "identity")

# 
bugs %>% 
  dplyr::select('#', 'トラッカー', 'ステータス', '作成日') %>% 
  dplyr::rename(ID = '#', Tracker = 'トラッカー', Status = 'ステータス',
                DateTime = '作成日') %>% 
  dplyr::mutate(Date = lubridate::as_date(DateTime)) %>% 
  dplyr::group_by(Date, Status) %>% 
  dplyr::tally() %>% 
  tidyr::spread(key = Status, value = n) %>% 
  dplyr::ungroup() %>%
  dplyr::mutate_at(vars(-Date), funs(replace(., is.na(.), 0))) %>% 
  dplyr::mutate_at(vars(-Date), funs(cumsum)) %>%
  tidyr::gather(key = Status, value = Count, -Date) %>%
  dplyr::ungroup() %>% 
  dplyr::group_by(Date) %>% 
  dplyr::tally(Count) %>% 
  ggplot2::ggplot(aes(x = Date)) +
    ggplot2::geom_line(aes(y = n)) 
```


### Cross Table
クロス集計結果に度数欄と累積度数を追加してみましょう。
```{r pivot, exercise=TRUE, exercise.setup="common"}
sum_date <- bugs %>%
  dplyr::group_by(date) %>%
  dplyr::count(date)

bugs_tbl <- bugs %>%
  dplyr::group_by(date, rank) %>%
  dplyr::count(date) %>% 
  tidyr::spread(key = rank, value = n)

bugs_tbl %>%
  dplyr::inner_join(sum_date) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(Cum = cumsum(n)) %>% 
  dplyr::rename(Sum = n)
```

```{r pivot-hint}
sum_date <- bugs %>%
  dplyr::group_by(date) %>%
  dplyr::count(date)

bugs_tbl <- bugs %>%
  dplyr::group_by(date, rank) %>%
  dplyr::count(date) %>% 
  tidyr::spread(key = rank, value = n)

bugs_tbl %>%
  dplyr::inner_join(sum_date) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(Cum = cumsum(n)) %>% 
  dplyr::rename(Sum = n)
```

### 列集計

## dplyr
http://dplyr.tidyverse.org/


---
![Sampo Suzuki][CCI]
[CC BY-NC-SA 4.0][CC], Sampo Suzuki [`r format(Sys.time(), format = '%F %H:%M(%Z)')`]

<!-- Creative Commons -->
[CC]: http://creativecommons.org/licenses/by-nc-sa/4.0/deed.ja "CC BY-NC-SA 4.0"
[CCI]: https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png "CC BY-NC-SA 4.0 icon"

<!-- R -->
[R]: https://www.r-project.org/ "The R Project"
[CRAN]: https://cran.r-project.org/ "CRAN"
[ISM]: https://cran.ism.ac.jp/ "CRAN ISM"

<!-- RStudio -->
[RS]: https://www.rstudio.com/ "RStudio"
[RSD]: https://www.rstudio.com/products/RStudio/#Desktop "RStudio Desktop"
[RSS]: https://www.rstudio.com/products/RStudio/#Server "RStudio Server"
[RM]: http://rmarkdown.rstudio.com/ "R Markdown form RStudio"
[RSH]: https://github.com/rstudio/RStartHere "R Start Here"
[R4DS]: http://r4ds.had.co.nz/ "R for Data Science"

<!-- Packages -->
[DT]: https://rstudio.github.io/DT/ "An R interface to the DataTables library"
[formatr]: https://yihui.name/formatr/ "Format R code automatically"
[knitr]: https://yihui.name/knitr/ "Elegant, flexible and fast dynamic report generation with R"
[learnr]: https://rstudio.github.io/learnr/ "Interactive Tutorials for R"
[shiny]: https://shiny.rstudio.com/ "Shiny by RStudio"
[tidy]: http://tidyverse.org/ "The tidyverse"

