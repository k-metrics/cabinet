---
title: "purrr"
output:
  html_document:
    df_print: paged
    code_folding: none
    css: style.css
    highlight: pygment
---

<!-- shared Links -->
```{r index, child="../shared/links.Rmd", include=FALSE}
```

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

require(tidyverse)
```

`purrr`パッケージは`apply`関数群が行うような反復処理をモダンなコーディングで実現するためのパッケージですが、比較的新しいパッケージであることや考え方が独特に見えることからあまり知られていないとパッケージだと思います。しかし、`dplyr::do`が将来的にディスコンになりそうなことや`broom`パッケージなどとの親和性が高いこと、`tidyverse`パッケージを読み込むと自動的に読み込まれることを考えると使わない手はありません。  
　  

```{r, eval=FALSE}
> library(tidyverse)
-- Attaching packages --------------------------------------- tidyverse 1.2.1 --
√ ggplot2 3.0.0     √ purrr   0.2.5
√ tibble  1.4.2     √ dplyr   0.7.6
√ tidyr   0.8.1     √ stringr 1.3.1
√ readr   1.1.1     √ forcats 0.3.0
-- Conflicts ------------------------------------------ tidyverse_conflicts() --
x .GlobalEnv::%||%() masks purrr::%||%()
x dplyr::filter()    masks stats::filter()
x dplyr::lag()       masks stats::lag()
```

　  　  
なお、本ページでは`r R.version$version.string`の標準パッケージ以外に以下の追加パッケージを用いています。  
　  

Package   | Version |Description
----------|---------|----------------------------------------------------------
tidyverse | `r packageVersion('tidyverse')` | Easily Install and Load the ‘Tidyverse’

　  

また、本ページでは以下のデータセットを用いています。  
　  

Dataset   | Package  | Version | Description
----------|----------|---------|----------------------------------------------
iris      | datasets | `r packageVersion('datasets')`| Edgar Anderson's Iris Data

　  

# purrr
`purrr`パッケージは[R for Data Science <i class="fa fa-external-link"></i>][R4DS]{target="_blank" title=""}の「21. Iteration」に分類されているように反復処理（ループ処理）をモダンなコーディングで実現するためのパッケージです。  
例えば`iris`データセットを品種（Species）毎に要約するような処理は`dplyr`パッケージを用いることで以下のようにで記述することが可能です。  
　  

```{r}
iris %>% 
  dplyr::group_by(Species) %>% 
  dplyr::summarise_all(mean)
```

　  
しかし、`dplyr`パッケージの場合、複数の返り値がある場合はデータフレーム型の制約から処理ができません。  
　  

```{r, error=TRUE}
iris %>% 
  dplyr::group_by(Species) %>% 
  dplyr::summarise_all(quantile)
```

　  
このような計算を行うには`dplyr::do`関数を用いて以下のように処理する必要があります。  
　  

```{r}
iris %>% 
  tidyr::gather(part, value, -Species) %>% 
  dplyr::group_by(Species, part) %>% 
  dplyr::do(qt = quantile(.$value)) %>%
  cbind(do.call(rbind, .$qt)) %>%
  dplyr::select(-qt)
```

　  
しかし、`dplyr::do`関数の後処理は慣れていないと記述が難しく可読性や保守性が高いとは言えません。ところが、`purrr`パッケージを用いると同様の処理は以下のように記述でき`dplyr::do`に比べると少し冗長なコードになりますが可読性や保守性が上がります。  
　  

```{r}
iris %>% 
  tidyr::gather(part, value, -Species) %>% 
  tidyr::unite("group", c(Species, part)) %>% 
  split(.$group) %>% 
  purrr::map(~ quantile(.$value)) %>% 
  purrr::map_dfr(broom::tidy, .id = "id") %>% 
  dplyr::mutate(names = forcats::as_factor(names), x = round(x, 2)) %>% 
  tidyr::spread(key = names, value = x) %>% 
  tidyr::separate(id, into = c("Species", "part"), sep = "_")

iris %>% 
  tidyr::gather(part, value, -Species) %>% 
  tidyr::unite("group", c(Species, part)) %>% 
  dplyr::group_by(group) %>% 
  tidyr::nest() %>%
  dplyr::mutate(out = purrr::map(data, ~ quantile(.$value)),
                out = purrr::map(out, broom::tidy)) %>% 
  tidyr::unnest(out) %>% 
  dplyr::mutate(names = forcats::as_factor(names), x = round(x, 2)) %>% 
  tidyr::spread(key = names, value = x) %>% 
  tidyr::separate(group, into = c("Species", "part"), sep = "_")
```

　  
このように複数の返り値があり`dplyr`パッケージだけでは処理しきれない場合に力を発揮するのが`purrr`パッケージです。  
　  

## `purrr::map`関数
`purrr::map`関数は`purrr`パッケージの中心となる関数です。`purrr::map`関数の考え方自体はシンプルで、第一引数で指定するベクトルまたはリストの各要素に対して、第二引数で指定する関数を適用するものです。  
例えば、`iris`データセットの品種（`Species`）ごとに回帰直線を計算する場合は以下のように記述します。  
　  

```{r}
iris %>% 
  split(.$Species) %>% 
  purrr::map(.x = .,
             .f = function(df) {
                    lm(Sepal.Width ~ Sepal.Length, data = df)
                  })
```

　  
ただ、これではp値などが分からないので、`summary`関数に`lm`関数の計算結果を渡します。  
　  

```{r}
iris %>% 
  split(.$Species) %>% 
  purrr::map(.x = .,
             .f = function(df) {
               lm(Sepal.Width ~ Sepal.Length, data = df) %>% summary()
             })
```

　  

ここまでの説明で気が付いた方もいらっしゃると思いますが、`lapply`関数でも同様の処理が可能ですが、`purrr::map`関数を使うメリットは別途説明します。  
　  

```{r}
iris %>% 
  split(.$Species) %>% 
  lapply(X = .,
         FUN = function(df){
           lm(Sepal.Width ~ Sepal.Length, data = df) %>% broom::tidy() #summary()
         })
```

　  

### 簡略表記
このように`purrr::map`関数は各要素に対する計算を行ってくれますが、コーディングが少し難解です。無名関数を用いるとコーディングを簡略化できます。  
　  

```{r}
iris %>% 
  split(.$Species) %>% 
  purrr::map(.x = .,
             .f = ~ lm(Sepal.Width ~ Sepal.Length, data = .x) %>% summary())
```

　  

### データフレーム化
ここまで見てきたように`purrr::map`関数の返り値はリスト型になり、その後の扱いが少々厄介です。`purrr::map_dfr`関数と`broom`パッケージを用いると返り値をひとつのデータフレーム型にまとめることができます。  
　  

```{r}
iris %>%
  base::split(.$Species) %>%
  purrr::map_dfr(~ lm(Sepal.Length ~ Sepal.Width, data = .x) %>% broom::tidy(),
                 .id = "Species")
```


```{r, error=TRUE}
# dplyr::do
iris %>% 
  dplyr::group_by(Species) %>% 
  dplyr::do(lm_res = lm(Sepal.Length ~ Sepal.Width, data = .)) %>% 
  broom::tidy(lm_res)

# purrr::map
iris %>%
  base::split(.$Species) %>%
  purrr::map_dfr(~ lm(Sepal.Length ~ Sepal.Width, data = .x) %>% broom::tidy(),
                 .id = "Species")
# purrr::map
iris %>% 
  base::split(.$Species) %>% 
  purrr::map(~ lm(Sepal.Length ~ Sepal.Width, data = .x)) %>%
  purrr::map_dfr(broom::tidy, .id = "Species") 
```

　  

### `dplyr::group_by`と併用する
`tidyverse`なモダンなコーディングなのだから`dplyr::group_by`を使って`purrr::map`処理をしたい！という場合には、`tidyr::nest`関数を用います。  

```{r}
# group_byを使う場合は一度nestする
iris %>% 
  dplyr::group_by(Species) %>%
  tidyr::nest() %>% 
  dplyr::mutate(out = purrr::map(data,
                                 ~ lm(Sepal.Length ~ Sepal.Width, data = .x) %>% 
                                   broom::tidy())) %>%
  tidyr::unnest(out)


iris %>% 
  dplyr::group_by(Species) %>%
  tidyr::nest() %>% 
  dplyr::mutate(out = purrr::map(data,
                                 ~ lm(Sepal.Length ~ Sepal.Width, data = .x))) %>% 
  dplyr::mutate(out2 = purrr::map(out, broom::tidy)) %>% 
  tidyr::unnest(out2)


iris %>% 
  dplyr::group_by(Species) %>%
  tidyr::nest() %>% 
  dplyr::mutate(out = purrr::map(data,
                                 ~ lm(Sepal.Length ~ Sepal.Width, data = .x)),
                out = purrr::map(out, broom::tidy)) %>% 
  tidyr::unnest(out)


iris %>% 
  tidyr::gather(part, value, -Species) %>% 
  tidyr::unite("group", c(Species, part)) %>% 
  dplyr::group_by(group) %>% 
  tidyr::nest() %>%
  dplyr::mutate(out = purrr::map(data, ~ quantile(.$value)),
                out = purrr::map(out, broom::tidy)) %>% 
  tidyr::unnest(out) %>% 
  dplyr::mutate(names = forcats::as_factor(names), x = round(x, 2)) %>% 
  tidyr::spread(key = names, value = x) %>% 
  tidyr::separate(group, into = c("Species", "part"), sep = "_")


```


```{r}
0:5 %>% 
  purrr::map_dfc(rnorm, n = 1000) %>% 
  # purrr::map_dfc(round, digits = 2) %>% 
  tidyr::gather(key = "key", value = "value") %>% 
  ggplot2::ggplot(ggplot2::aes(x = value, y = ..density.., fill = key)) + 
    # ggplot2::geom_histogram(alpha = 0.5, position = "identity") + 
    ggplot2::geom_density(alpha = 0.5)
```

```{r}
mtcars %>% 
  base::split(.$cyl) %>% 
  purrr::map(~ lm(mpg ~ wt, data = .x)) %>%
  purrr::map_dfr(broom::tidy, .id = "id") 
```

```{r}
ggplot2::mpg %>% 
  base::split(.$manufacturer) %>% 
  purrr::map(~ lm(cty ~ displ, data = .x)) %>%
  purrr::map_dfr(broom::tidy, .id = "id") %>% 
  tidyr::gather(key = "key", value = "value", -id, -term) %>% 
  dplyr::mutate(value = round(value, 2)) %>% 
  tidyr::spread(key, value)
```

　  

## purrr::map2関数

# 応用例
## 複数のファイルに対する処理
### ファイルデータの結合
### 任意の列の抽出

http://www.r-bloggers.com/use-quick-formula-functions-in-purrrmap-base-vs-tidtyverse-idiom-comparisonsexamples/
　  

# 参考資料

* [purrr part of the tidyverse <i class="fa fa-external-link"></i>](https://purrr.tidyverse.org/){target="_blank" title="tidyverse.org"}
* [そろそろ手を出すpurrr <i class="fa fa-external-link"></i>](https://speakerdeck.com/s_uryu/nekosky){target="_blank" title="Speaker Deck"}
* [purrr — ループ処理やapply系関数の決定版 <i class="fa fa-external-link"></i>](https://heavywatal.github.io/rstats/purrr.html){target="_blank" title="Heavy Watal"}
* [{purrr} でリストデータを操作する <1> <i class="fa fa-external-link"></i>](http://sinhrks.hatenablog.com/entry/2015/11/26/220956){target="_blank" title="StatsFragments"}
* [{purrr} でリストデータを操作する <2> <i class="fa fa-external-link"></i>](http://sinhrks.hatenablog.com/entry/2015/11/28/213859){target="_blank" title="StatsFragments"}
* [メモ: multi-gatherをpurrrでやってみる <i class="fa fa-external-link"></i>](https://notchained.hatenablog.com/entry/2017/12/06/131248){target="_blank" title="Technically, technophobic."}
* [do()とかrowwise()は今から覚える必要はない（たぶん） <i class="fa fa-external-link"></i>](https://notchained.hatenablog.com/entry/2017/11/15/212117){target="_blank" title="Technically, technophobic."}
* [purrr 0.2.3を使ってみる <i class="fa fa-external-link"></i>](https://notchained.hatenablog.com/entry/2017/08/04/104256){target="_blank" title="Technically, technophobic."}
* [purrrの使い方 <i class="fa fa-external-link"></i>](http://delta0726.web.fc2.com/packages/data/00_purrr.html){target="_blank" title="FC2 Web"}

　  

---

<!-- Footer -->
```{r child="../shared/footer.Rmd"}
```